unit Unit3;

interface

uses
  Winapi.Windows, Winapi.Messages, System.Variants,
  System.Classes, Vcl.Graphics,
  ActiveX, Vcl.Controls, Vcl.StdCtrls, Vcl.Forms, Vcl.Grids, ComObj,
  Vcl.Dialogs,
  IdBaseComponent, IdComponent, IdTCPConnection, IdTCPClient, IdHTTP,
  Vcl.ComCtrls,
  System.NetEncoding, IdSSLOpenSSL, System.JSON, RegularExpressions,
  System.StrUtils,
  System.Net.HttpClient, System.Net.HttpClientComponent, Registry, Vcl.ExtCtrls,
  IdCookieManager,
  IdSSL, IdCompressorZLib, Vcl.OleCtrls, SHDocVw, uCEFChromiumCore,
  uCEFChromium, Winapi.ShellAPI, Vcl.Menus, System.Generics.Collections, IniFiles,System.Zip,
  CWMIBase, CServiceInfo, CComputerSystemInfo;



  type
  ANIMATIONINFO = record
    cbSize: UINT;
    iMinAnimate: Integer; // nonzero to enable animation; 0 disables it
  end;
  PANIMATIONINFO = ^ANIMATIONINFO;


  type
  TStartupKeyInfo = record
    Root: HKEY;
    KeyPath: string;
    Source: string;   // Friendly name (e.g. 'HKCU\Run', 'HKLM\RunOnce', etc.)
    IsDisabled: Boolean; // True if this key stores disabled startup items.
    Flags: DWORD;     // Registry access flags (for example, KEY_WOW64_64KEY)
  end;

type
  TForm3 = class(TForm)
    FilterTimer: TTimer;
    PopupMenu1: TPopupMenu;
    SearchGoogle1: TMenuItem;
    FindDriver1: TMenuItem;
    PageControl1: TPageControl;
    TabSheet1: TTabSheet;
    TabSheet2: TTabSheet;
    TabSheet3: TTabSheet;
    ListView1: TListView;
    ListView2: TListView;
    Panel1: TPanel;
    GridPanel1: TGridPanel;
    EditFilter: TEdit;
    chkHideUnknown: TCheckBox;
    chkNoDriver: TCheckBox;
    Button1: TButton;
    Button4: TButton;
    Button5: TButton;
    ProgressBar1: TProgressBar;
    LogMemo: TMemo;
    lvStartUp: TListView;
    Button2: TButton;
    ProgressBar2: TProgressBar;
    GridPanel2: TGridPanel;
    Panel2: TPanel;
    Panel3: TPanel;
    Panel4: TPanel;
    Button22: TButton;
    Button20: TButton;
    Button15: TButton;
    Button14: TButton;
    Button9: TButton;
    Button7: TButton;
    Button6: TButton;
    Button3: TButton;
    Button27: TButton;
    Button26: TButton;
    Button24: TButton;
    Button23: TButton;
    Button25: TButton;
    Button38: TButton;
    Button8: TButton;
    Button10: TButton;
    Button28: TButton;
    Button29: TButton;
    Button30: TButton;
    Button31: TButton;
    Button32: TButton;
    Button33: TButton;
    Button34: TButton;
    Button36: TButton;
    Button37: TButton;
    Button35: TButton;
    Button11: TButton;
    Button12: TButton;
    Button13: TButton;
    Button21: TButton;
    Button16: TButton;
    Button17: TButton;
    Button18: TButton;
    Button19: TButton;
    Button39: TButton;
    Button40: TButton;
    Button41: TButton;
    Button42: TButton;
    Button43: TButton;
    Button44: TButton;
    Button45: TButton;
    Button46: TButton;
    Button47: TButton;
    Button48: TButton;
    Button49: TButton;
    Button50: TButton;
    Button51: TButton;
    Button52: TButton;
    Button53: TButton;
    Button54: TButton;
    TabSheet4: TTabSheet;
    GroupBox1: TGroupBox;
    lbOS: TLabel;
    GroupBox2: TGroupBox;
    lbProductKey: TLabel;
    lbInstallDate: TLabel;
    LabelProgress: TLabel;
    Services: TTabSheet;
    sgServices: TStringGrid;
    GroupBox3: TGroupBox;
    Button55: TButton;
    btnRefresh: TButton;
    Button56: TButton;
    Button57: TButton;
    Button58: TButton;
    Button59: TButton;
    cbStart: TComboBox;
    Button60: TButton;
    ServiceInfo1: TServiceInfo;
    sbMain: TStatusBar;
    GroupBox4: TGroupBox;
    lbComputerName: TLabel;
    lbDescription: TLabel;
    GroupBox5: TGroupBox;
    lbRAM: TLabel;
    GroupBox6: TGroupBox;
    lbDrive: TLabel;
    GroupBox7: TGroupBox;
    lbBIOS: TLabel;
    lbCPU: TLabel;
    lbGPU: TLabel;
    lbMB: TLabel;
    UserName: TLabel;
    SystemType: TLabel;
    SearchGoogleDeviceName1: TMenuItem;
    procedure Button1Click(Sender: TObject);
    procedure Button2Click(Sender: TObject);
    procedure Button3Click(Sender: TObject);

    // >>> ADDED 1: We add two new event handlers for searching <<<
    procedure EditFilterChange(Sender: TObject);
    procedure FilterTimerTimer(Sender: TObject);
    procedure ListView1DblClick(Sender: TObject);
    procedure Button6Click(Sender: TObject);
    procedure chkHideUnknownClick(Sender: TObject);
    procedure Button7Click(Sender: TObject);
    procedure Button8Click(Sender: TObject);
    procedure IndyDrivePackClick(Sender: TObject);
    procedure PopupMenu1Popup(Sender: TObject);
    procedure SearchGoogle1Click(Sender: TObject);

    procedure FindDriver1Click(Sender: TObject);
    procedure FormShow(Sender: TObject);
    procedure EditFilterMouseLeave(Sender: TObject);
    procedure FormCreate(Sender: TObject);
    procedure FormDestroy(Sender: TObject);
    procedure chkNoDriverClick(Sender: TObject);
    procedure lvStartUpDblClick(Sender: TObject);
    procedure Button9Click(Sender: TObject);
    procedure Button10Click(Sender: TObject);
    procedure Button11Click(Sender: TObject);
    procedure Button12Click(Sender: TObject);
    procedure Button13Click(Sender: TObject);
    procedure Button14Click(Sender: TObject);
    procedure Button15Click(Sender: TObject);
    procedure Button16Click(Sender: TObject);
    procedure Button17Click(Sender: TObject);
    procedure Button18Click(Sender: TObject);
    procedure Button19Click(Sender: TObject);
    procedure Button20Click(Sender: TObject);
    procedure Button21Click(Sender: TObject);
    procedure Button22Click(Sender: TObject);
    procedure Button23Click(Sender: TObject);
    procedure Button24Click(Sender: TObject);
    procedure Button25Click(Sender: TObject);
    procedure Button26Click(Sender: TObject);
    procedure Button27Click(Sender: TObject);
    procedure Button28Click(Sender: TObject);
    procedure Button29Click(Sender: TObject);
    procedure Button30Click(Sender: TObject);
    procedure Button31Click(Sender: TObject);
    procedure Button32Click(Sender: TObject);
    procedure Button33Click(Sender: TObject);
    procedure Button34Click(Sender: TObject);
    procedure Button35Click(Sender: TObject);
    procedure Button36Click(Sender: TObject);
    procedure Button37Click(Sender: TObject);
    procedure Button38Click(Sender: TObject);
    procedure Button39Click(Sender: TObject);
    procedure FormClose(Sender: TObject; var Action: TCloseAction);
    procedure Button41Click(Sender: TObject);
    procedure lvStartUpItemChecked(Sender: TObject; Item: TListItem);
    procedure Button42Click(Sender: TObject);
    procedure Button43Click(Sender: TObject);
    procedure Button44Click(Sender: TObject);
    procedure Button45Click(Sender: TObject);
    procedure Button46Click(Sender: TObject);
    procedure Button47Click(Sender: TObject);
    procedure Button48Click(Sender: TObject);
    procedure Button49Click(Sender: TObject);
    procedure Button50Click(Sender: TObject);
    procedure Button51Click(Sender: TObject);
    procedure Button52Click(Sender: TObject);
    procedure Button53Click(Sender: TObject);
    procedure Button54Click(Sender: TObject);
    procedure ServicesShow(Sender: TObject);
    procedure btnRefreshClick(Sender: TObject);
    procedure Button61Click(Sender: TObject);
    procedure Button62Click(Sender: TObject);
    procedure FormPaint(Sender: TObject);
    procedure Button4Click(Sender: TObject);
    procedure Button5Click(Sender: TObject);
    procedure SearchGoogleDeviceName1Click(Sender: TObject);

  private
    FDeviceHuntURL: string; // form-level variable
    { Private declarations }
    procedure QueryAllDrivers;
    procedure DisplaySearchResults(const HTMLContent: string);
    // >>> ADDED 2: We add these helper methods and a TStringList to backup the ListView items <<<
    procedure ApplySearchFilter(const AFilter: string);
    procedure LocateDriverOnOS(const DriverKey: string);
    function  GetMotherboardInfo: string;
    procedure SearchMotherboardDrivers;
    procedure HighlightSearchMatches(const AFilter: string);
    procedure CheckForDriverUpdates;
    procedure InstallDriverUpdates;
    procedure PopulateDriverUpdates;
    procedure InstallSelectedDriverUpdates;
    Procedure ShowMainInfo;
    procedure HttpReceiveData(const Sender: TObject; AContentLength, AReadCount: Int64; var Abort: Boolean);
    procedure CargarDatosGrid();
  public
    { Public declarations }
  end;

var
  Form3: TForm3;
  QueryUrl: String;
  Width: Integer;
  GDeviceHuntURL: string; // global var to store the final URL
  // >>> ADDED 3: Keep a backup of the original items so that we can refilter <<<
  FOriginalItems: TStringList;
   FUpdateList: TList<OleVariant>;
implementation

{$R *.dfm}

uses
  System.IOUtils, System.Threading, System.SysUtils, SplashFormUnit;
function GetFirmwareEnvironmentVariable(lpName, lpGuid: PChar; pBuffer: Pointer; nSize: DWORD): DWORD; stdcall; external kernel32 name 'GetFirmwareEnvironmentVariableW';


procedure showComputerInfo;
var
  SInfo:TComputerSystemInfo;
  p:TComputerSystemProperties;
  Str:String;
begin

    SInfo := TComputerSystemInfo.Create(nil);
  sInfo.Active := True;
  p := sInfo.ComputerSystemProperties;


  form3.lbComputerName.Caption:= 'Computer Name: ' +p.Caption;
  form3.lbDescription.Caption:= 'Description: ' + p.Description;
  Form3.UserName.Caption:= 'User Name: ' + p.UserName;
  Form3.SystemType.Caption:= 'System Type: ' + p.SystemType;
  Str := Str +
    'Computer Name: ' + p.Caption + sLineBreak +
    'Descripcion: ' + p.Description + sLineBreak +
    'User Name: ' + p.UserName + sLineBreak +
    'Domain: ' + p.Domain + sLineBreak +
    'Roles: ' + p.RolesAsString + sLineBreak +
    'Manufacturer: ' + p.Manufacturer + sLineBreak +
    'Model: ' + p.Model + sLineBreak +
    'System Family: ' + p.SystemFamily + sLineBreak +
    'System Type: ' + p.SystemType + sLineBreak;
  //ShowMessage(Str);
end;
procedure TForm3.CargarDatosGrid();
var
  i:Integer;
begin
  //
  sgServices.Cells[0, 0] := 'ID';
  sgServices.Cells[0, 1] := 'Name';
  sgServices.Cells[0, 2] := 'FileName';
  sgServices.Cells[0, 3] := 'State';
  sgServices.Cells[0, 4] := 'Start Mode';

  sgServices.RowCount := ServiceInfo1.ObjectsCount;


  // Cargar el Grid
  for i := 0 to (ServiceInfo1.ObjectsCount - 1) do begin
    ServiceInfo1.ObjectIndex := i + 1;

    sgServices.Cells[0, i + 1] := IntToStr(ServiceInfo1.ServiceProperties.ProcessId);
    sgServices.Cells[1, i + 1] := ServiceInfo1.ServiceProperties.DisplayName;
    sgServices.Cells[2, i + 1] := ExtractFileName(ServiceInfo1.ServiceProperties.PathName);
    sgServices.Cells[3, i + 1] := ServiceInfo1.ServiceProperties.State;
    sgServices.Cells[4, i + 1] := ServiceInfo1.ServiceProperties.StartMode;
  end;

end;






 procedure TForm3.HttpReceiveData(
  const Sender: TObject;
  AContentLength, AReadCount: Int64;
  var Abort: Boolean
);
var
  Percent: Double;
begin
  if (AContentLength > 0) and (ProgressBar1 <> nil) then
  begin
    Percent := (AReadCount / AContentLength) * 100;
    // Update UI: Ensure you're in the main thread
    TThread.Queue(nil,
      procedure
      begin
        ProgressBar1.Position := Trunc(Percent);
        if LabelProgress <> nil then
          LabelProgress.Caption := Format('Downloaded: %.0f%%', [Percent]);
          Application.ProcessMessages;
      end
    );
  end;
end;





const
  // Define the common startup keys.
  StartupKeys: array[0..5] of TStartupKeyInfo = (
    (Root: HKEY_CURRENT_USER; KeyPath: 'Software\Microsoft\Windows\CurrentVersion\Run';
     Source: 'HKCU\Run'; IsDisabled: False),
    (Root: HKEY_CURRENT_USER; KeyPath: 'Software\Microsoft\Windows\CurrentVersion\RunOnce';
     Source: 'HKCU\RunOnce'; IsDisabled: False),
    (Root: HKEY_CURRENT_USER; KeyPath: 'Software\Microsoft\Windows\CurrentVersion\RunDisabled';
     Source: 'HKCU\RunDisabled'; IsDisabled: True),
    (Root: HKEY_LOCAL_MACHINE; KeyPath: 'Software\Microsoft\Windows\CurrentVersion\Run';
     Source: 'HKLM\Run'; IsDisabled: False),
    (Root: HKEY_LOCAL_MACHINE; KeyPath: 'Software\Microsoft\Windows\CurrentVersion\RunOnce';
     Source: 'HKLM\RunOnce'; IsDisabled: False),
    (Root: HKEY_LOCAL_MACHINE; KeyPath: 'Software\Microsoft\Windows\CurrentVersion\RunDisabled';
     Source: 'HKLM\RunDisabled'; IsDisabled: True)
  );
const
  // Registry keys for startup apps
  StartupKey_CU = 'Software\Microsoft\Windows\CurrentVersion\Run';
  StartupDisabledKey_CU = 'Software\Microsoft\Windows\CurrentVersion\RunDisabled';

   // Registry keys for local machine (requires elevated rights)
  StartupKey_LM = 'Software\Microsoft\Windows\CurrentVersion\Run';
  StartupDisabledKey_LM = 'Software\Microsoft\Windows\CurrentVersion\RunDisabled';
  CustomStartupDisabledKey_LM = 'Software\YourApp\StartupDisabled';
{*
  Lists startup applications from the HKCU enabled and disabled keys.
  This method populates a given ListView with:
    - App Name
    - Command (the value stored)
    - Status ("Enabled" or "Disabled")
*}


const
  SPDRP_DRIVER = $00000009; // Property to retrieve the driver version
  SPDRP_DEVICEDESC = $00000000; // Device description property

  DIGCF_DEFAULT = $00000001;
  DIGCF_PRESENT = $00000002;
  DIGCF_ALLCLASSES = $00000004;
  SPDRP_HARDWAREID = $00000001;
  SPDRP_COMPATIBLEIDS = $00000002;
  SPDRP_UNUSED0 = $00000003;
  SPDRP_SERVICE = $00000004;
  SPDRP_UNUSED1 = $00000005;
  SPDRP_UNUSED2 = $00000006;
  SPDRP_CLASS = $00000007; // Device setup class
  SPDRP_CLASSGUID = $00000008; // GUID of the device setup class
  SPDRP_CONFIGFLAGS = $0000000A;
  SPDRP_MFG = $0000000B; // Manufacturer name
  SPDRP_FRIENDLYNAME = $0000000C;
  SPDRP_LOCATION_INFORMATION = $0000000D;
  SPDRP_PHYSICAL_DEVICE_OBJECT_NAME = $0000000E;
  SPDRP_CAPABILITIES = $0000000F;
  SPDRP_UI_NUMBER = $00000010;
  SPDRP_UPPERFILTERS = $00000011;
  SPDRP_LOWERFILTERS = $00000012;

  REGISTRY_BASE_PATH = 'SYSTEM\CurrentControlSet\Control\Class\';

type
  HDEVINFO = THandle;
  PSP_DEVINFO_DATA = ^SP_DEVINFO_DATA;

  SP_DEVINFO_DATA = packed record
    cbSize: DWORD;
    ClassGuid: TGUID;
    DevInst: DWORD;
    Reserved: ULONG_PTR;
  end;










type
  TEdgeRegEntry = record
    RootStr: string; // 'HKLM' or 'HKCU'
    KeyPath: string;
    Name: string;
    Value: Integer;
    OriginalValue: Integer;
  end;

const
  // Define an array of registry settings for Edge debloat.
  // (Adjust as needed; duplicate entries have been removed.)
  EdgeRegEntries: array[0..18] of TEdgeRegEntry = (
    (RootStr: 'HKLM'; KeyPath: 'SOFTWARE\Policies\Microsoft\EdgeUpdate'; Name: 'CreateDesktopShortcutDefault'; Value: 0; OriginalValue: 1),
    (RootStr: 'HKLM'; KeyPath: 'SOFTWARE\Policies\Microsoft\Edge'; Name: 'EdgeEnhanceImagesEnabled'; Value: 0; OriginalValue: 1),
    (RootStr: 'HKLM'; KeyPath: 'SOFTWARE\Policies\Microsoft\Edge'; Name: 'PersonalizationReportingEnabled'; Value: 0; OriginalValue: 1),
    (RootStr: 'HKLM'; KeyPath: 'SOFTWARE\Policies\Microsoft\Edge'; Name: 'ShowRecommendationsEnabled'; Value: 0; OriginalValue: 1),
    (RootStr: 'HKLM'; KeyPath: 'SOFTWARE\Policies\Microsoft\Edge'; Name: 'HideFirstRunExperience'; Value: 1; OriginalValue: 0),
    (RootStr: 'HKLM'; KeyPath: 'SOFTWARE\Policies\Microsoft\Edge'; Name: 'UserFeedbackAllowed'; Value: 0; OriginalValue: 1),
    (RootStr: 'HKLM'; KeyPath: 'SOFTWARE\Policies\Microsoft\Edge'; Name: 'ConfigureDoNotTrack'; Value: 1; OriginalValue: 0),
    (RootStr: 'HKLM'; KeyPath: 'SOFTWARE\Policies\Microsoft\Edge'; Name: 'AlternateErrorPagesEnabled'; Value: 0; OriginalValue: 1),
    (RootStr: 'HKLM'; KeyPath: 'SOFTWARE\Policies\Microsoft\Edge'; Name: 'EdgeCollectionsEnabled'; Value: 0; OriginalValue: 1),
    (RootStr: 'HKLM'; KeyPath: 'SOFTWARE\Policies\Microsoft\Edge'; Name: 'EdgeFollowEnabled'; Value: 0; OriginalValue: 1),
    (RootStr: 'HKLM'; KeyPath: 'SOFTWARE\Policies\Microsoft\Edge'; Name: 'EdgeShoppingAssistantEnabled'; Value: 0; OriginalValue: 1),
    (RootStr: 'HKLM'; KeyPath: 'SOFTWARE\Policies\Microsoft\Edge'; Name: 'MicrosoftEdgeInsiderPromotionEnabled'; Value: 0; OriginalValue: 1),
    (RootStr: 'HKLM'; KeyPath: 'SOFTWARE\Policies\Microsoft\Edge'; Name: 'ShowMicrosoftRewards'; Value: 0; OriginalValue: 1),
    (RootStr: 'HKLM'; KeyPath: 'SOFTWARE\Policies\Microsoft\Edge'; Name: 'WebWidgetAllowed'; Value: 0; OriginalValue: 1),
    (RootStr: 'HKLM'; KeyPath: 'SOFTWARE\Policies\Microsoft\Edge'; Name: 'DiagnosticData'; Value: 0; OriginalValue: 1),
    (RootStr: 'HKLM'; KeyPath: 'SOFTWARE\Policies\Microsoft\Edge'; Name: 'EdgeAssetDeliveryServiceEnabled'; Value: 0; OriginalValue: 1),
    (RootStr: 'HKLM'; KeyPath: 'SOFTWARE\Policies\Microsoft\Edge'; Name: 'CryptoWalletEnabled'; Value: 0; OriginalValue: 1),
    (RootStr: 'HKLM'; KeyPath: 'SOFTWARE\Policies\Microsoft\Edge'; Name: 'ConfigureDoNotTrack'; Value: 1; OriginalValue: 0),
    (RootStr: 'HKLM'; KeyPath: 'SOFTWARE\Policies\Microsoft\Edge'; Name: 'WalletDonationEnabled'; Value: 0; OriginalValue: 1)
  );




  procedure DownloadAndInstall(const ADownloadURL, ALocalFile: string);
var
  HTTPClient: THTTPClient;
  Response: IHTTPResponse;
begin
  HTTPClient := THTTPClient.Create;
  try
    // Download the file
    Response := HTTPClient.Get(ADownloadURL);
    if Response.StatusCode = 200 then
    begin
      // Save the downloaded stream to file
      Response.ContentStream.Position := 0;
      with TFileStream.Create(ALocalFile, fmCreate) do
      try
        CopyFrom(Response.ContentStream, Response.ContentStream.Size);
      finally
        Free;
      end;

      // Run the downloaded executable.
      if ShellExecute(Application.Handle, 'open', PChar(ALocalFile),
        nil, nil, SW_SHOWNORMAL) <= 32 then
      begin
        raise Exception.Create('Failed to start installer.');
      end;
    end
    else
      raise Exception.CreateFmt('Download failed. HTTP status: %d',
        [Response.StatusCode]);
  finally
    HTTPClient.Free;
  end;
end;

 procedure DownloadFileWithProgress(
  const ADownloadURL, ALocalFile: string;
  AProgressBar: TProgressBar;
  AProgressLabel: TLabel
);
var
  HTTPClient: THTTPClient;
  Response: IHTTPResponse;
begin
  HTTPClient := THTTPClient.Create;
  try
    // Assign your regular method here
    HTTPClient.OnReceiveData := form3.HttpReceiveData;

    Response := HTTPClient.Get(ADownloadURL);
    if Response.StatusCode = 200 then
    begin
      // Save the downloaded content
      Response.ContentStream.Position := 0;
      with TFileStream.Create(ALocalFile, fmCreate) do
      try
        CopyFrom(Response.ContentStream, Response.ContentStream.Size);
      finally
        Free;
      end;
    end
    else
      raise Exception.CreateFmt('Download failed. HTTP status: %d', [Response.StatusCode]);
  finally
    HTTPClient.Free;
  end;
end;


 procedure DownloadFile(const ADownloadURL, ALocalFile: string);
var
  HTTPClient: THTTPClient;
  Response: IHTTPResponse;
begin
  HTTPClient := THTTPClient.Create;
  try
    // Perform the download
    Response := HTTPClient.Get(ADownloadURL);
    if Response.StatusCode = 200 then
    begin
      // Write the response stream to a file
      Response.ContentStream.Position := 0;
      with TFileStream.Create(ALocalFile, fmCreate) do
      try
        CopyFrom(Response.ContentStream, Response.ContentStream.Size);
      finally
        Free;
      end;
    end
    else
      raise Exception.CreateFmt('Download failed. HTTP status: %d', [Response.StatusCode]);
  finally
    HTTPClient.Free;
  end;
end;
  procedure ExtractZip(const AZipFile, ADestFolder: string);
var
  ZipFile: TZipFile;
begin
  ZipFile := TZipFile.Create;
  try
    // Open the ZIP file for reading and extract all contents
    ZipFile.Open(AZipFile, zmRead);
    ZipFile.ExtractAll(ADestFolder);
  finally
    ZipFile.Free;
  end;
end;

function GetGPUInfo: string;
var
  Locator, WMIService, GPUList, vGPU: OleVariant;
  Enum: IEnumVariant;
  Dummy: Cardinal;
begin
  try
    // Create the WMI locator and connect to the CIMV2 namespace.
    Locator := CreateOleObject('WbemScripting.SWbemLocator');
    WMIService := Locator.ConnectServer('.', 'root\CIMV2');
    // Execute the query to get GPU information.
    GPUList := WMIService.ExecQuery('SELECT * FROM Win32_VideoController');
    // Get the enumerator from the returned collection.
    Enum := IUnknown(GPUList._NewEnum) as IEnumVariant;
    // Retrieve the first GPU in the collection.
    if Enum.Next(1, vGPU, Dummy) = 0 then
      Result := Format('GPU: %s, Driver Version: %s', [vGPU.Name, vGPU.DriverVersion])
    else
      Result := 'GPU info not found';
  except
    on E: Exception do
    begin
      if Assigned(form3.LogMemo) then
        form3.LogMemo.Lines.Add('Error in GetGPUInfo: ' + E.Message);
      Result := 'GPU info not found due to error';
    end;
  end;
end;

function GetBootMode: string;
var
  Ret: Cardinal;
begin
  // Call with four parameters: empty variable name, a dummy GUID, nil buffer, and buffer size 0.
  Ret := GetFirmwareEnvironmentVariable('', '{00000000-0000-0000-0000-000000000000}', nil, 0);
  if Ret <> 0 then
    Result := 'UEFI'
  else
    Result := 'Legacy BIOS';
end;

function GetOSInfo: string;
var
  Locator, WMIService, OSList, vOS: OleVariant;
  Enum: IEnumVariant;
  Dummy: Cardinal;
begin
  try
    Locator := CreateOleObject('WbemScripting.SWbemLocator');
    WMIService := Locator.ConnectServer('.', 'root\CIMV2');
    OSList := WMIService.ExecQuery('SELECT * FROM Win32_OperatingSystem');
    // Get the enumerator from the collection.
    Enum := IUnknown(OSList._NewEnum) as IEnumVariant;
    // Get the first element.
    if Enum.Next(1, vOS, Dummy) = 0 then
      Result := Format('OS: %s (Version: %s, Build: %s) - Boot Mode: %s',
                [VarToStr(vOS.Caption),
                 VarToStr(vOS.Version),
                 VarToStr(vOS.BuildNumber),
                 GetBootMode])
    else
      Result := 'OS info not found';
  except
    on E: Exception do
    begin
      if Assigned(form3.LogMemo) then
        form3.LogMemo.Lines.Add('Error in GetOSInfo: ' + E.Message);
      Result := 'OS info not found due to error';
    end;
  end;
end;
function GetCPUInfo: string;
var
  Locator, WMIService, CPUList, vCPU: OleVariant;
  Enum: IEnumVariant;
  Dummy: Cardinal;
  CPUName: string;
  Cores, ClockSpeed: Integer;
begin
  try
    Locator := CreateOleObject('WbemScripting.SWbemLocator');
    WMIService := Locator.ConnectServer('.', 'root\CIMV2');
    CPUList := WMIService.ExecQuery('SELECT * FROM Win32_Processor');
    Enum := IUnknown(CPUList._NewEnum) as IEnumVariant;
    if Enum.Next(1, vCPU, Dummy) = 0 then
    begin
      CPUName := VarToStr(vCPU.Name);
      Cores := Integer(VarAsType(vCPU.NumberOfCores, varInteger));
      ClockSpeed := Integer(VarAsType(vCPU.MaxClockSpeed, varInteger));
      Result := Format('CPU: %s, Cores: %d, Clock Speed: %d MHz',
        [CPUName, Cores, ClockSpeed]);
    end
    else
      Result := 'CPU info not found';
  except
    on E: Exception do
    begin
      if Assigned(form3.LogMemo) then
        form3.LogMemo.Lines.Add('Error in GetCPUInfo: ' + E.Message);
      Result := 'CPU info not found due to error';
    end;
  end;
end;
function GetDriveInfo: string;
var
  Locator, WMIService, DriveList, vDrive: OleVariant;
  Enum: IEnumVariant;
  Dummy: Cardinal;
  s: string;
begin
  s := '';
  try
    Locator := CreateOleObject('WbemScripting.SWbemLocator');
    WMIService := Locator.ConnectServer('.', 'root\CIMV2');
    DriveList := WMIService.ExecQuery('SELECT * FROM Win32_DiskDrive');
    Enum := IUnknown(DriveList._NewEnum) as IEnumVariant;
    while Enum.Next(1, vDrive, Dummy) = 0 do
    begin
      s := s + Format('Drive: %s, Model: %s, Size: %.2f GB' + sLineBreak,
        [VarToStr(vDrive.DeviceID), VarToStr(vDrive.Model),
         Extended(VarAsType(vDrive.Size, varDouble)) / (1024 * 1024 * 1024)]);
    end;
    Result := s;
  except
    on E: Exception do
      Result := 'Drive info not found due to error: ' + E.Message;
  end;
end;

//function GetDriveInfo: string;
//var
//  Locator, WMIService, DriveList, vDrive: OleVariant;
//  Enum: IEnumVariant;
//  Dummy: Cardinal;
//  s: string;
//  DriveID, Model: string;
//  SizeGB: Extended;
//begin
//  s := '';
//  try
//    Locator := CreateOleObject('WbemScripting.SWbemLocator');
//    WMIService := Locator.ConnectServer('.', 'root\CIMV2');
//    DriveList := WMIService.ExecQuery('SELECT * FROM Win32_DiskDrive');
//    Enum := IUnknown(DriveList._NewEnum) as IEnumVariant;
//    while Enum.Next(1, vDrive, Dummy) = 0 do
//    begin
//      DriveID := VarToStr(vDrive.DeviceID);
//      Model := VarToStr(vDrive.Model);
//      // Convert Size to Extended; if conversion fails, default to 0.
//      SizeGB := Extended(VarAsType(vDrive.Size, varDouble)) / (1024 * 1024 * 1024);
//      s := s + Format('Drive: %s, Model: %s, Size: %.2f GB<br>',
//        [DriveID, Model, SizeGB]);
//    end;
//    Result := s;
//  except
//    on E: Exception do
//    begin
//      if Assigned(form3.LogMemo) then
//        form3.LogMemo.Lines.Add('Error in GetDriveInfo: ' + E.Message);
//      Result := 'Drive info not found due to error';
//    end;
//  end;
//end;


{*
  This function decodes the Windows Product Key from the binary value
  "DigitalProductId" stored in the registry.
  (Note: This algorithm works for systems where the key is stored in this way,
  but on newer systems with digital licenses the key may not be available.)
*}
function GetWmiProductKey: string;
var
  Locator, WMIService, SLS, vItem: OleVariant;
  Enum: IEnumVariant;
  Dummy: Cardinal;
begin
  Result := 'Not Available';
  try
    Locator := CreateOleObject('WbemScripting.SWbemLocator');
    WMIService := Locator.ConnectServer('.', 'root\CIMV2');
    SLS := WMIService.ExecQuery('SELECT OA3xOriginalProductKey FROM SoftwareLicensingService');
    Enum := IUnknown(SLS._NewEnum) as IEnumVariant;
    if Enum.Next(1, vItem, Dummy) = 0 then
    begin
      // If the returned key is empty, use a default message.
      if VarToStr(vItem.OA3xOriginalProductKey) = '' then
        Result := 'Product Key Not Available'
      else
        Result := VarToStr(vItem.OA3xOriginalProductKey);
    end;
  except
    on E: Exception do
      Result := 'Error retrieving product key via WMI: ' + E.Message;
  end;
end;



{*
  Generates an HTML report that includes system information such as the OS,
  CPU, GPU, Hard Drives, and Windows product key.
*}
procedure GenerateSystemReport;
var
  Report: TStringList;
  ReportFile: string;
  OSInfo, CPUInfo, GPUInfo, DriveInfo, ProductKey: string;
begin
  Report := TStringList.Create;
  try
    // Gather system information.
    OSInfo := GetOSInfo;
    CPUInfo := GetCPUInfo;
    GPUInfo := GetGPUInfo;
    DriveInfo := GetDriveInfo;
    // Use the alternate product key approach.
    ProductKey := GetWmiProductKey;

    // Define the path for the HTML report.
    ReportFile := IncludeTrailingPathDelimiter(GetCurrentDir) + 'SystemReport.html';

    Report.Add('<html>');
    Report.Add('<head><title>System Report</title>');
    Report.Add('<style>body { font-family: Arial, sans-serif; } h1 { color: #333; }');
    Report.Add('table { border-collapse: collapse; } th, td { border: 1px solid #ccc; padding: 8px; }</style>');
    Report.Add('</head>');
    Report.Add('<body>');
    Report.Add('<h1>System Report</h1>');

    Report.Add('<h2>Operating System</h2>');
    Report.Add('<p>' + OSInfo + '</p>');

    Report.Add('<h2>CPU</h2>');
    Report.Add('<p>' + CPUInfo + '</p>');

    Report.Add('<h2>GPU</h2>');
    Report.Add('<p>' + GPUInfo + '</p>');

    Report.Add('<h2>Hard Drives</h2>');
    Report.Add('<p>' + DriveInfo + '</p>');

    Report.Add('<h2>Windows Product Key</h2>');
    Report.Add('<p>' + ProductKey + '</p>');

    Report.Add('</body>');
    Report.Add('</html>');

    // Save the HTML content to a file.
    Report.SaveToFile(ReportFile);

    // Open the generated HTML file in the default browser.
    ShellExecute(0, 'open', PChar(ReportFile), nil, nil, SW_SHOWNORMAL);
  finally
    Report.Free;
  end;
end;
function GetRAMInfo: string;
var
  Locator, WMIService, RAMList, vRAM: OleVariant;
  Enum: IEnumVariant;
  Dummy: Cardinal;
  s: string;
  Capacity: Extended;
  ModuleInfo: string;
begin
  s := '';
  try
    Locator := CreateOleObject('WbemScripting.SWbemLocator');
    WMIService := Locator.ConnectServer('.', 'root\CIMV2');
    RAMList := WMIService.ExecQuery('SELECT * FROM Win32_PhysicalMemory');
    Enum := IUnknown(RAMList._NewEnum) as IEnumVariant;
    while Enum.Next(1, vRAM, Dummy) = 0 do
    begin
      // Convert capacity from bytes to GB.
      Capacity := Extended(VarAsType(vRAM.Capacity, varDouble)) / (1024 * 1024 * 1024);
      ModuleInfo := Format('Slot: %s, Manufacturer: %s, Capacity: %.2f GB, Speed: %s MHz',
        [VarToStr(vRAM.DeviceLocator),
         VarToStr(vRAM.Manufacturer),
         Capacity,
         VarToStr(vRAM.Speed)]);
      s := s + ModuleInfo + sLineBreak;
    end;
    if s = '' then
      s := 'No RAM info found';
    Result := s;
  except
    on E: Exception do
      Result := 'Error retrieving RAM info: ' + E.Message;
  end;
end;



function FormatWMIDate(const WMIDate: string): string;
var
  Year, Month, Day: Word;
begin
  // Ensure we have at least 8 characters (YYYYMMDD)
  if Length(WMIDate) < 8 then
    Exit(WMIDate);

  Year := StrToIntDef(Copy(WMIDate, 1, 4), 0);
  Month := StrToIntDef(Copy(WMIDate, 5, 2), 0);
  Day := StrToIntDef(Copy(WMIDate, 7, 2), 0);

  if (Year > 0) and (Month > 0) and (Day > 0) then
    Result := Format('%.2d/%.2d/%.4d', [Month, Day, Year])
  else
    Result := WMIDate;
end;

function GetBIOSInfo: string;
var
  Locator, WMIService, BIOSList, vBIOS: OleVariant;
  Enum: IEnumVariant;
  Dummy: Cardinal;
  ReleaseDate: string;
begin
  try
    Locator := CreateOleObject('WbemScripting.SWbemLocator');
    WMIService := Locator.ConnectServer('.', 'root\CIMV2');
    BIOSList := WMIService.ExecQuery('SELECT * FROM Win32_BIOS');
    Enum := IUnknown(BIOSList._NewEnum) as IEnumVariant;
    if Enum.Next(1, vBIOS, Dummy) = 0 then
    begin
      // Convert the release date into a friendly format.
      ReleaseDate := FormatWMIDate(VarToStr(vBIOS.ReleaseDate));
      Result := Format('BIOS: %s, Version: %s, Release Date: %s',
        [VarToStr(vBIOS.Manufacturer),
         VarToStr(vBIOS.SMBIOSBIOSVersion),
         ReleaseDate]);
    end
    else
      Result := 'BIOS info not found';
  except
    on E: Exception do
      Result := 'Error retrieving BIOS info: ' + E.Message;
  end;
end;


function TForm3.GetMotherboardInfo: string;
var
  WbemLocator, WMIService, MBList, MB: OleVariant;
  Enum: IEnumVariant;
  Dummy: Cardinal;
  MBManufacturer, MBProduct, MBVersion: string;
begin
  Result := 'Motherboard info not found';
  LogMemo.Lines.Add('Querying motherboard information...');
  CoInitialize(nil);
  try
    // Create the WMI locator and connect to the CIMV2 namespace.
    WbemLocator := CreateOleObject('WbemScripting.SWbemLocator');
    WMIService := WbemLocator.ConnectServer('.', 'root\CIMV2');
    // Execute a query on the Win32_BaseBoard class.
    MBList := WMIService.ExecQuery('SELECT Manufacturer, Product, Version FROM Win32_BaseBoard');
    Enum := IUnknown(MBList._NewEnum) as IEnumVariant;
    // Retrieve the first element.
    if Enum.Next(1, MB, Dummy) = 0 then
    begin
      MBManufacturer := VarToStr(MB.Manufacturer);
      MBProduct := VarToStr(MB.Product);
      MBVersion := VarToStr(MB.Version);
      LogMemo.Lines.Add('Motherboard Manufacturer: ' + MBManufacturer);
      LogMemo.Lines.Add('Motherboard Product: ' + MBProduct);
      LogMemo.Lines.Add('Motherboard Version: ' + MBVersion);
      Result := Format('Motherboard: %s %s (Version: %s)', [MBManufacturer, MBProduct, MBVersion]);
    end
    else
      LogMemo.Lines.Add('No motherboard information found.');
  finally
    CoUninitialize;
  end;
end;

function WMIDateToDateTime(const WMIDate: string): TDateTime;
var
  s: string;
  fs: TFormatSettings;
begin
  // Ensure we have at least 14 characters (YYYYMMDDHHMMSS)
  if Length(WMIDate) < 14 then
    Exit(0);

  // Reformat the string to "YYYY-MM-DD HH:NN:SS"
  s := Copy(WMIDate, 1, 4) + '-' +
       Copy(WMIDate, 5, 2) + '-' +
       Copy(WMIDate, 7, 2) + ' ' +
       Copy(WMIDate, 9, 2) + ':' +
       Copy(WMIDate, 11, 2) + ':' +
       Copy(WMIDate, 13, 2);

  fs := TFormatSettings.Create;
  fs.DateSeparator := '-';
  fs.TimeSeparator := ':';
  fs.ShortDateFormat := 'yyyy-mm-dd';
  fs.LongTimeFormat := 'hh:nn:ss';

  Result := StrToDateTime(s, fs);
end;


function GetWindowsInstallDate: string;
var
  Locator, WMIService, OSList, vOS: OleVariant;
  Enum: IEnumVariant;
  Dummy: Cardinal;
  WMIDate: string;
  InstallDate: TDateTime;
begin
  try
    Locator := CreateOleObject('WbemScripting.SWbemLocator');
    WMIService := Locator.ConnectServer('.', 'root\CIMV2');
    OSList := WMIService.ExecQuery('SELECT InstallDate FROM Win32_OperatingSystem');
    Enum := IUnknown(OSList._NewEnum) as IEnumVariant;
    if Enum.Next(1, vOS, Dummy) = 0 then
    begin
      WMIDate := VarToStr(vOS.InstallDate);
      InstallDate := WMIDateToDateTime(WMIDate);
      // Format the date as MM/DD/YYYY
      Result := FormatDateTime('mm/dd/yyyy', InstallDate);
    end
    else
      Result := 'Install date not found';
  except
    on E: Exception do
      Result := 'Error retrieving install date: ' + E.Message;
  end;
end;


procedure TForm3.ShowMainInfo;
var
  InstallDate, OSInfo, CPUInfo, GPUInfo, DriveInfo, RAMInfo, ProductKey: string;
  MBInfo, BIOSInfo: string;
begin
  showComputerInfo;
  // Step 1: Retrieve OS information.
  SplashForm.UpdateProgress(10, 'Gathering OS info...');
  OSInfo := GetOSInfo;

  // Step 2: Retrieve CPU information.
  SplashForm.UpdateProgress(20, 'Retrieving CPU info...');
  CPUInfo := GetCPUInfo;

  // Step 3: Retrieve GPU information.
 SplashForm.UpdateProgress(30, 'Getting GPU info...');
  GPUInfo := GetGPUInfo;

  // Step 4: Retrieve Drive info.
  SplashForm.UpdateProgress(40, 'Collecting drive info...');
  DriveInfo := GetDriveInfo;

  // Step 5: Retrieve RAM info.
  SplashForm.UpdateProgress(50, 'Checking RAM info...');
  RAMInfo := GetRAMInfo;

  // Step 6: Retrieve Motherboard info.
  SplashForm.UpdateProgress(60, 'Querying motherboard info...');
  MBInfo := GetMotherboardInfo;

  // Step 7: Retrieve BIOS info.
  SplashForm.UpdateProgress(70, 'Retrieving BIOS info...');
  BIOSInfo := GetBIOSInfo;

  // Step 8: Retrieve Product Key.
 SplashForm.UpdateProgress(80, 'Getting product key...');
  ProductKey := GetWmiProductKey;

  // Step 9: Retrieve Install Date.
  SplashForm.UpdateProgress(90, 'Checking install date...');
  InstallDate := GetWindowsInstallDate;

  // Set labels on the main form.
  lbOS.Caption         := OSInfo;
  lbCPU.Caption        := CPUInfo;
  lbGPU.Caption        := GPUInfo;
  lbDrive.Caption      := DriveInfo;
  lbRAM.Caption        := RAMInfo;
  lbMB.Caption         := MBInfo;
  lbBIOS.Caption       := BIOSInfo;
  lbProductKey.Caption := ProductKey;
  lbInstallDate.Caption:= 'Install Date ' + InstallDate;

  // Final update before finishing.
  SplashForm.UpdateProgress(100, 'Initialization complete.');

  // Optionally, wait a brief moment to let the user see the 100% state.
  Sleep(200);

  // Close the splash screen.
  form3.show;
  SplashForm.Hide;
end;

procedure GenerateSystemReportAsync;
var
  Report: TStringList;
  ReportFile: string;
  OSInfo, CPUInfo, GPUInfo, DriveInfo, RAMInfo, ProductKey: string;
  MBInfo, BIOSInfo: string;
begin
  CoInitialize(nil);  // Initialize COM for this thread.
  try
    Report := TStringList.Create;
    try
      // Retrieve system information.
      OSInfo := GetOSInfo;
      CPUInfo := GetCPUInfo;
      GPUInfo := GetGPUInfo;
      DriveInfo := GetDriveInfo;
      RAMInfo := GetRAMInfo;
      //MBInfo := GetMotherboardInfo;
      BIOSInfo := GetBIOSInfo;
      ProductKey := GetWmiProductKey;  // Using the WMI method for product key

      // Define the HTML report file path.
      ReportFile := IncludeTrailingPathDelimiter(GetCurrentDir) + 'SystemReport.html';

      Report.Add('<html>');
      Report.Add('<head><title>System Report</title>');
      Report.Add('<style>body { font-family: Arial, sans-serif; } h1 { color: #333; }');
      Report.Add('table { border-collapse: collapse; } th, td { border: 1px solid #ccc; padding: 8px; }</style>');
      Report.Add('</head>');
      Report.Add('<body>');
      Report.Add('<h1>System Report</h1>');

      Report.Add('<h2>Operating System</h2>');
      Report.Add('<p>' + OSInfo + '</p>');

      Report.Add('<h2>CPU</h2>');
      Report.Add('<p>' + CPUInfo + '</p>');

      Report.Add('<h2>GPU</h2>');
      Report.Add('<p>' + GPUInfo + '</p>');

      Report.Add('<h2>Hard Drives</h2>');
      Report.Add('<p>' + DriveInfo + '</p>');

      Report.Add('<h2>RAM</h2>');
      Report.Add('<p>' + RAMInfo + '</p>');

      Report.Add('<h2>Main Board</h2>');
      Report.Add('<p>' + MBInfo + '</p>');

      Report.Add('<h2>BIOS</h2>');
      Report.Add('<p>' + BIOSInfo + '</p>');

      Report.Add('<h2>Windows Product Key</h2>');
      Report.Add('<p>' + ProductKey + '</p>');

      Report.Add('</body>');
      Report.Add('</html>');

      Report.SaveToFile(ReportFile);

      // Synchronize back to the main thread to open the file.
      TThread.Synchronize(nil,
        procedure
        begin
          ShellExecute(0, 'open', PChar(ReportFile), nil, nil, SW_SHOWNORMAL);
        end);
    finally
      Report.Free;
    end;
  finally
    CoUninitialize;
  end;
end;



procedure DebloatEdgeNoJSON(LogMemo: TMemo);
var
  i: Integer;
  RegEntry: TEdgeRegEntry;
  Reg: TRegistry;
  Root: HKEY;
begin
  LogMemo.Lines.Add('Starting Edge debloat registry changes...');
  for i := Low(EdgeRegEntries) to High(EdgeRegEntries) do
  begin
    RegEntry := EdgeRegEntries[i];
    // Determine root key
    if SameText(RegEntry.RootStr, 'HKLM') then
      Root := HKEY_LOCAL_MACHINE
    else if SameText(RegEntry.RootStr, 'HKCU') then
      Root := HKEY_CURRENT_USER
    else
    begin
      LogMemo.Lines.Add(Format('Unknown root "%s" for %s', [RegEntry.RootStr, RegEntry.Name]));
      Continue;
    end;
    // Create TRegistry with KEY_ALL_ACCESS and 64-bit view.
    Reg := TRegistry.Create(KEY_ALL_ACCESS or KEY_WOW64_64KEY);
    try
      Reg.RootKey := Root;
      if Reg.OpenKey(RegEntry.KeyPath, True) then
      begin
        try
          Reg.WriteInteger(RegEntry.Name, RegEntry.Value);
          LogMemo.Lines.Add(Format('Set %s\%s = %d (was %d)', [RegEntry.KeyPath, RegEntry.Name, RegEntry.Value, RegEntry.OriginalValue]));
        except
          on E: Exception do
            LogMemo.Lines.Add(Format('Error writing %s\%s: %s', [RegEntry.KeyPath, RegEntry.Name, E.Message]));
        end;
        Reg.CloseKey;
      end
      else
        LogMemo.Lines.Add(Format('Failed to open key: %s', [RegEntry.KeyPath]));
    finally
      Reg.Free;
    end;
  end;
  LogMemo.Lines.Add('Edge debloat registry settings applied.');
end;









const
  STARTUP_ENABLED:  array[0..1] of Byte = ($02, $00); // 02 00 means “enabled”
  STARTUP_DISABLED: array[0..1] of Byte = ($03, $00); // 03 00 means “disabled”

procedure SetStartupApproved(const AName: string; Enable: Boolean; UserScope: Boolean; LogMemo: TMemo);
var
  Reg: TRegistry;
  SubKey: string;
begin
  // For user startup items, update the "Run" subkey under StartupApproved.
  if UserScope then
    SubKey := 'Software\Microsoft\Windows\CurrentVersion\Explorer\StartupApproved\Run'
  else
    SubKey := 'SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\StartupApproved\Run';

  Reg := TRegistry.Create(KEY_WRITE or KEY_WOW64_64KEY);
  try
    if UserScope then
      Reg.RootKey := HKEY_CURRENT_USER
    else
      Reg.RootKey := HKEY_LOCAL_MACHINE;

    if Reg.OpenKey(SubKey, True) then
    begin
      if Enable then
        Reg.WriteBinaryData(AName, STARTUP_ENABLED[0], Length(STARTUP_ENABLED))
         //SendMessage(HWND_BROADCAST, WM_SETTINGCHANGE, 0, 0);
      else
        Reg.WriteBinaryData(AName, STARTUP_DISABLED[0], Length(STARTUP_DISABLED));
      Reg.CloseKey;
       //SendMessage(HWND_BROADCAST, WM_SETTINGCHANGE, 0, 0);
    end
    else
      LogMemo.Lines.Add('Unable to open key: ' + SubKey);
  finally
    Reg.Free;
  end;

  if Enable then
    LogMemo.Lines.Add(Format('StartupApproved set: "%s" Enabled.', [AName]))
  else
    LogMemo.Lines.Add(Format('StartupApproved set: "%s" Disabled.', [AName]));
end;





procedure DisableNotificationCenter(LogMemo: TMemo);
var
  Reg: TRegistry;
begin
  Reg := TRegistry.Create(KEY_ALL_ACCESS or KEY_WOW64_64KEY);
  try
    Reg.RootKey := HKEY_CURRENT_USER;
    if Reg.OpenKey('Software\Policies\Microsoft\Windows\Explorer', True) then
    begin
      Reg.WriteInteger('DisableNotificationCenter', 1);
      LogMemo.Lines.Add('Notification Center has been disabled.');
      Reg.CloseKey;
    end
    else
      LogMemo.Lines.Add('Failed to open registry key for disabling Notification Center.');
  except
    on E: Exception do
      LogMemo.Lines.Add('Error disabling Notification Center: ' + E.Message);
  end;
  Reg.Free;

  // Post a message so that Windows picks up the change.
  PostMessage(HWND_BROADCAST, WM_SETTINGCHANGE, 0,
    LPARAM(PChar('Software\Policies\Microsoft\Windows\Explorer')));
  LogMemo.Lines.Add('WM_SETTINGCHANGE message posted.');
end;

procedure EnableNotificationCenter(LogMemo: TMemo);
var
  Reg: TRegistry;
begin
  Reg := TRegistry.Create(KEY_ALL_ACCESS or KEY_WOW64_64KEY);
  try
    Reg.RootKey := HKEY_CURRENT_USER;
    if Reg.OpenKey('Software\Policies\Microsoft\Windows\Explorer', True) then
    begin
      // Remove the value so that the default behavior is restored.
      if Reg.ValueExists('DisableNotificationCenter') then
      begin
        Reg.DeleteValue('DisableNotificationCenter');
        LogMemo.Lines.Add('Notification Center has been enabled.');
      end
      else
        LogMemo.Lines.Add('Notification Center was not disabled.');
      Reg.CloseKey;
    end
    else
      LogMemo.Lines.Add('Failed to open registry key for enabling Notification Center.');
  except
    on E: Exception do
      LogMemo.Lines.Add('Error enabling Notification Center: ' + E.Message);
  end;
  Reg.Free;

  PostMessage(HWND_BROADCAST, WM_SETTINGCHANGE, 0,
    LPARAM(PChar('Software\Policies\Microsoft\Windows\Explorer')));
  LogMemo.Lines.Add('WM_SETTINGCHANGE message posted.');
end;





procedure EnableStartupApp(const AName, ACommand: string; LogMemo: TMemo);
var
  Reg: TRegistry;
begin
  LogMemo.Lines.Add(Format('Enabling startup app "%s"...',[AName]));

  // 1) Write the command to HKCU\Run
  Reg := TRegistry.Create(KEY_WRITE or KEY_WOW64_64KEY);
  try
    Reg.RootKey := HKEY_CURRENT_USER;
    if Reg.OpenKey('Software\Microsoft\Windows\CurrentVersion\Run', True) then
    begin
      Reg.WriteString(AName, ACommand);
      Reg.CloseKey;
    end;
  finally
    Reg.Free;
  end;

  // 2) Mark it as "Enabled" in StartupApproved
  Reg := TRegistry.Create(KEY_WRITE or KEY_WOW64_64KEY);
  try
    Reg.RootKey := HKEY_CURRENT_USER;
    if Reg.OpenKey('Software\Microsoft\Windows\CurrentVersion\Explorer\StartupApproved\Run', True) then
    begin
      // Write 02 00
      Reg.WriteBinaryData(AName, STARTUP_ENABLED[0], Length(STARTUP_ENABLED));
      Reg.CloseKey;
    end;
  finally
    Reg.Free;
  end;

  LogMemo.Lines.Add(Format('"%s" enabled in Windows startup.', [AName]));
end;




procedure DisableStartupApp(const AName: string; LogMemo: TMemo);
var
  Reg: TRegistry;
begin
  LogMemo.Lines.Add(Format('Disabling startup app "%s"...',[AName]));

  // 1) Remove from HKCU\Run so it won't actually run
  Reg := TRegistry.Create(KEY_WRITE or KEY_WOW64_64KEY);
  try
    Reg.RootKey := HKEY_CURRENT_USER;
    if Reg.OpenKey('Software\Microsoft\Windows\CurrentVersion\Run', False) then
    begin
      if Reg.ValueExists(AName) then
        Reg.DeleteValue(AName);
      Reg.CloseKey;
    end;
  finally
    Reg.Free;
  end;

  // 2) Mark it as "Disabled" in StartupApproved
  Reg := TRegistry.Create(KEY_WRITE or KEY_WOW64_64KEY);
  try
    Reg.RootKey := HKEY_CURRENT_USER;
    if Reg.OpenKey('Software\Microsoft\Windows\CurrentVersion\Explorer\StartupApproved\Run', True) then
    begin
      // Write 03 00
      Reg.WriteBinaryData(AName, STARTUP_DISABLED[0], Length(STARTUP_DISABLED));
      Reg.CloseKey;
    end;
  finally
    Reg.Free;
  end;

  LogMemo.Lines.Add(Format('"%s" disabled in Windows startup.', [AName]));
end;




procedure UpdateCheckboxesFromStatus(ListView: TListView);
var
  i: Integer;
  StatusText: string;
begin
  ListView.Items.BeginUpdate;
  try
    for i := 0 to ListView.Items.Count - 1 do
    begin
      // Assuming Status is stored in SubItems[1]
      if ListView.Items[i].SubItems.Count >= 2 then
      begin
        StatusText := LowerCase(ListView.Items[i].SubItems[1]);
        if StatusText = 'enabled' then
          ListView.Items[i].Checked := True
        else if StatusText = 'disabled' then
          ListView.Items[i].Checked := False;
      end;
    end;
  finally
    ListView.Items.EndUpdate;
  end;
end;



 procedure LoadStartupState(ListView: TListView; const IniFileName: string);
var
  Ini: TIniFile;
  i: Integer;
  State: Integer;
begin
  Ini := TIniFile.Create(IniFileName);
  try
    // Loop through each ListView item and load the saved state.
    for i := 0 to ListView.Items.Count - 1 do
    begin
      // Default to 0 (unchecked) if not found.
      State := Ini.ReadInteger('StartupApps', ListView.Items[i].Caption, 0);
      ListView.Items[i].Checked := (State <> 0);
    end;
  finally
    Ini.Free;
  end;
end;



procedure SaveStartupState(ListView: TListView; const IniFileName: string);
var
  Ini: TIniFile;
  i: Integer;
begin
  Ini := TIniFile.Create(IniFileName);
  try
    // Loop through each ListView item and save the checked state.
    for i := 0 to ListView.Items.Count - 1 do
    begin
      // Write 1 if checked, 0 if not checked.
      Ini.WriteInteger('StartupApps', ListView.Items[i].Caption, Ord(ListView.Items[i].Checked));
    end;
  finally
    Ini.Free;
  end;
end;




procedure UpdateProgress(ProgressBar: TProgressBar; Current, Total: Integer);
begin
  ProgressBar.Min := 0;
  ProgressBar.Max := Total;
  ProgressBar.Position := Current;
  Application.ProcessMessages; // allow UI to update
end;




  // -----------------------------------------------------------------------------
  // Original ANSI Declarations (unchanged)
  // -----------------------------------------------------------------------------
function SetupDiGetClassDevsA(ClassGuid: PGUID; Enumerator: PAnsiChar;
  hwndParent: HWND; Flags: DWORD): HDEVINFO; stdcall; external 'SetupAPI.dll';

function SetupDiEnumDeviceInfo(DeviceInfoSet: HDEVINFO; MemberIndex: DWORD;
  DeviceInfoData: PSP_DEVINFO_DATA): BOOL; stdcall; external 'SetupAPI.dll';

function SetupDiGetDeviceInstanceIdA(DeviceInfoSet: HDEVINFO;
  DeviceInfoData: PSP_DEVINFO_DATA; DeviceInstanceId: PAnsiChar;
  DeviceInstanceIdSize: DWORD; RequiredSize: PDWORD): BOOL; stdcall;
  external 'SetupAPI.dll';

function SetupDiGetDeviceRegistryPropertyA(DeviceInfoSet: HDEVINFO;
  DeviceInfoData: PSP_DEVINFO_DATA; Property_: DWORD;
  PropertyRegDataType: PDWORD; PropertyBuffer: PBYTE; PropertyBufferSize: DWORD;
  RequiredSize: PDWORD): BOOL; stdcall; external 'SetupAPI.dll';

function SetupDiDestroyDeviceInfoList(DeviceInfoSet: HDEVINFO): BOOL; stdcall;
  external 'SetupAPI.dll';
function ExtractScope(const Source: string): string;
begin
  // If the source string contains 'HKLM', return 'HKLM'; if it contains 'HKCU', return 'HKCU'
  if Pos('HKLM', UpperCase(Source)) > 0 then
    Result := 'HKLM'
  else if Pos('HKCU', UpperCase(Source)) > 0 then
    Result := 'HKCU'
  else
    Result := '';
end;



function IsElevated: Boolean;
var
  hToken: THandle;
  Elevation: TOKEN_ELEVATION;
  dwSize: DWORD;
begin
  Result := False;
  if OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, hToken) then
  try
    if GetTokenInformation(hToken, TokenElevation, @Elevation, SizeOf(Elevation), dwSize) then
      Result := Elevation.TokenIsElevated <> 0;
  finally
    CloseHandle(hToken);
  end;
end;




 type
  RESTOREPOINTINFO = record
    dwEventType: DWORD;
    dwRestorePtType: DWORD;
    llSequenceNumber: Int64;
    szDescription: array[0..127] of WideChar;
  end;
  PRESTOREPOINTINFO = ^RESTOREPOINTINFO;

  STATEMGRSTATUS = record
    nStatus: DWORD;
    llSequenceNumber: Int64;
  end;
  PSTATEMGRSTATUS = ^STATEMGRSTATUS;

function SRSetRestorePointW(pRestorePtSpec: PRESTOREPOINTINFO; pSMgrStatus: PSTATEMGRSTATUS): BOOL; stdcall; external 'srclient.dll';

procedure CreateSystemRestorePoint(const Description: string; LogMemo: TMemo);
var
  RestorePt: RESTOREPOINTINFO;
  SMgrStatus: STATEMGRSTATUS;
  DescW: array[0..127] of WideChar;
begin
  // Begin the restore point creation.
  ZeroMemory(@RestorePt, SizeOf(RestorePt));
  RestorePt.dwEventType := 100;  // BEGIN_SYSTEM_CHANGE
  // You can choose an appropriate restore point type (0 is commonly used for application installs)
  RestorePt.dwRestorePtType := 0;
  RestorePt.llSequenceNumber := 0;
  // Convert the description to a WideChar array.
  StringToWideChar(Description, DescW, Length(DescW));
  Move(DescW, RestorePt.szDescription, SizeOf(RestorePt.szDescription));

  if not SRSetRestorePointW(@RestorePt, @SMgrStatus) then
  begin
    LogMemo.Lines.Add('Failed to create restore point (BEGIN).');
    Exit;
  end
  else
    LogMemo.Lines.Add(Format('Restore point (BEGIN) created. Sequence: %d', [SMgrStatus.llSequenceNumber]));

  // End the restore point creation.
  RestorePt.dwEventType := 101;  // END_SYSTEM_CHANGE
  RestorePt.llSequenceNumber := SMgrStatus.llSequenceNumber;
  if not SRSetRestorePointW(@RestorePt, @SMgrStatus) then
    LogMemo.Lines.Add('Failed to finalize restore point (END).')
  else
    LogMemo.Lines.Add('Restore point finalized successfully.');
end;









{*
  Helper procedure that runs a PowerShell command in hidden mode.
  (See previous examples for RunPowerShellCommand.)
*}



procedure RunPowerShellCommand(const CmdLine: string; LogMemo: TMemo);
var
  sei: TShellExecuteInfo;
  ExitCode: DWORD;
begin
  FillChar(sei, SizeOf(sei), 0);
  sei.cbSize := SizeOf(sei);
  sei.fMask := SEE_MASK_NOCLOSEPROCESS or SEE_MASK_FLAG_NO_UI;
  sei.lpVerb := 'runas'; // Run as administrator
  sei.lpFile := 'PowerShell.exe';
  // Build parameters string: -NoProfile -Command "<your command>"
  sei.lpParameters := PChar('-NoProfile -Command "' + CmdLine + '"');
  sei.nShow := SW_HIDE; // Hide the PowerShell window
  if ShellExecuteEx(@sei) then
  begin
    // Wait for the process to complete
    WaitForSingleObject(sei.hProcess, INFINITE);
    if GetExitCodeProcess(sei.hProcess, ExitCode) then
      LogMemo.Lines.Add(Format('Command "%s" completed with exit code %d.', [CmdLine, ExitCode]))
    else
      LogMemo.Lines.Add(Format('Command "%s" completed, but exit code not retrieved.', [CmdLine]));
    CloseHandle(sei.hProcess);
  end
  else
    LogMemo.Lines.Add(Format('Failed to run command: "%s". Error code: %d', [CmdLine, GetLastError]));
end;



 procedure InstallAVG(LogMemo: TMemo);
var
  Cmd: string;
begin
  // Build the PowerShell command string.
  // Adjust the URL if needed.
  Cmd :=
    '[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12; ' +
    '$downloadUrl = "https://bits.avcdn.net/productfamily_ANTIVIRUS/insttype_FREE/platform_WIN_AVG/installertype_ONLINE/build_RELEASE/cookie_mmm_bav_013_999_a9c_m:dlid_FREEGSR?ref=clid_692601704.1742080960--seid_1742080959--senu_1&alt=en-us"; ' +
    '$destination = "$env:temp\AVGSetup.exe"; ' +
    'Write-Output "Downloading AVG installer from $downloadUrl..."; ' +
    'Invoke-WebRequest -Uri $downloadUrl -OutFile $destination -UseBasicParsing -Headers @{ "User-Agent" = "Mozilla/5.0 (Windows NT 10.0; Win64; x64)" }; ' +
    'if (Test-Path $destination) { ' +
    '    Write-Output "Download complete. Executing installer..."; ' +
    '    Start-Process -FilePath $destination -Wait; ' +
    '    Write-Output "AVG installer executed." ' +
    '} else { ' +
    '    Write-Error "Download failed. File not found." ' +
    '}';
  RunPowerShellCommand(Cmd, LogMemo);
end;



procedure OpenURL(const URL: string);
begin
  if ShellExecute(0, 'open', PChar(URL), nil, nil, SW_SHOWNORMAL) <= 32 then
    raise Exception.Create('Failed to open URL: ' + URL);
end;




procedure ToggleSystemRestore(Enable: Boolean; LogMemo: TMemo);
const
  KeyPath = 'SOFTWARE\Policies\Microsoft\Windows NT\SystemRestore';
var
  Reg: TRegistry;
begin
  Reg := TRegistry.Create(KEY_ALL_ACCESS or KEY_WOW64_64KEY);
  try
    Reg.RootKey := HKEY_LOCAL_MACHINE;
    if Reg.OpenKey(KeyPath, True) then
    begin
      if Enable then
      begin
        // To enable System Restore, remove the DisableSR value if it exists.
        if Reg.ValueExists('DisableSR') then
          Reg.DeleteValue('DisableSR');
        LogMemo.Lines.Add('System Restore has been enabled.');
      end
      else
      begin
        // To disable System Restore, set DisableSR to 1.
        Reg.WriteInteger('DisableSR', 1);
        LogMemo.Lines.Add('System Restore has been disabled.');
      end;
      Reg.CloseKey;
    end
    else
      LogMemo.Lines.Add('Failed to open key: ' + KeyPath);
  except
    on E: Exception do
      LogMemo.Lines.Add('Error toggling System Restore: ' + E.Message);
  end;
  Reg.Free;
  LogMemo.Lines.Add('A reboot may be required for changes to take effect.');
end;



 procedure InvokeUltimatePerformance(const State: string; LogMemo: TMemo);
var
  Cmd: string;
begin
  // For enabling Ultimate Performance
  if SameText(State, 'Enable') then
  begin
    // If Ultimate Performance is not already installed, duplicate it.
    // Then, extract its GUID and set it active.
    Cmd := 'if (!(powercfg -list | Select-String -Pattern "Ultimate Performance")) ' +
           '{ powercfg -duplicatescheme e9a42b02-d5df-448d-aa00-03f14749eb61 } ; ' +
           '$ultimatePlanGUID = (powercfg -list | Select-String -Pattern "Ultimate Performance").Line.Split()[3]; ' +
           'powercfg -setactive $ultimatePlanGUID; ' +
           'Write-Output "Ultimate Performance plan is now active."';
    RunPowerShellCommand(Cmd, LogMemo);
  end
  else if SameText(State, 'Disable') then
  begin
    // If Ultimate Performance is installed, extract its GUID, set a balanced plan active, and delete the ultimate plan.
    Cmd := 'if (powercfg -list | Select-String -Pattern "Ultimate Performance") ' +
           '{ $ultimatePlanGUID = (powercfg -list | Select-String -Pattern "Ultimate Performance").Line.Split()[3]; ' +
           '$balancedPlanGUID = (powercfg -list | Select-String -Pattern "Balanced").Line.Split()[3]; ' +
           'powercfg -setactive $balancedPlanGUID; ' +
           'powercfg -delete $ultimatePlanGUID; ' +
           'Write-Output "Ultimate Performance plan has been uninstalled. Balanced plan is now active." } ' +
           'else { Write-Output "Ultimate Performance plan is not installed." }';
    RunPowerShellCommand(Cmd, LogMemo);
  end
  else
    LogMemo.Lines.Add('Unknown state provided. Use "Enable" or "Disable".');
end;





procedure InstallMalwarebytes(LogMemo: TMemo);
var
  Cmd: string;
begin
  // Updated command with -UseBasicParsing.
  Cmd := '$downloadUrl = "https://data-cdn.mbamupdates.com/web/"; ' +
         '$destination = "$env:temp\mb3-setup-consumer-3.0.6.1469.exe"; ' +
         'Write-Output "Downloading Malwarebytes installer from $downloadUrl..."; ' +
         'Invoke-WebRequest -Uri $downloadUrl -OutFile $destination -UseBasicParsing; ' +
         'Write-Output "Download complete. Executing installer..."; ' +
         'Start-Process -FilePath $destination -Wait; ' +
         'Write-Output "Malwarebytes installer executed."';
  RunPowerShellCommand(Cmd, LogMemo);
end;






procedure ResetWindowsUpdate(LogMemo: TMemo);
var
  WindowsDir: array[0..MAX_PATH] of Char;
  SoftwareDistributionFolder, Catroot2Folder: string;
begin
  LogMemo.Lines.Add('--- Resetting Windows Update ---');

  // Step 1: Stop Windows Update related services.
  RunPowerShellCommand('net stop wuauserv', LogMemo);
  RunPowerShellCommand('net stop bits', LogMemo);
  RunPowerShellCommand('net stop cryptsvc', LogMemo);
  RunPowerShellCommand('net stop msiserver', LogMemo);

  Sleep(2000); // wait for services to stop

  // Step 2: Delete the SoftwareDistribution and catroot2 folders.
  if GetWindowsDirectory(WindowsDir, MAX_PATH) <> 0 then
  begin
    SoftwareDistributionFolder := IncludeTrailingPathDelimiter(WindowsDir) + 'SoftwareDistribution';
    Catroot2Folder := IncludeTrailingPathDelimiter(WindowsDir) + 'System32\catroot2';

    try
      if TDirectory.Exists(SoftwareDistributionFolder) then
      begin
        TDirectory.Delete(SoftwareDistributionFolder, True);
        LogMemo.Lines.Add('Deleted SoftwareDistribution folder.');
      end
      else
        LogMemo.Lines.Add('SoftwareDistribution folder not found.');
    except
      on E: Exception do
        LogMemo.Lines.Add('Error deleting SoftwareDistribution: ' + E.Message);
    end;

    try
      if TDirectory.Exists(Catroot2Folder) then
      begin
        TDirectory.Delete(Catroot2Folder, True);
        LogMemo.Lines.Add('Deleted catroot2 folder.');
      end
      else
        LogMemo.Lines.Add('catroot2 folder not found.');
    except
      on E: Exception do
        LogMemo.Lines.Add('Error deleting catroot2: ' + E.Message);
    end;
  end
  else
    LogMemo.Lines.Add('Failed to get Windows directory.');

  Sleep(2000); // wait a bit before restarting services

  // Step 3: Restart the services.
  RunPowerShellCommand('net start wuauserv', LogMemo);
  RunPowerShellCommand('net start bits', LogMemo);
  RunPowerShellCommand('net start cryptsvc', LogMemo);
  RunPowerShellCommand('net start msiserver', LogMemo);

  LogMemo.Lines.Add('--- Windows Update Reset complete. Please restart your computer if necessary. ---');
end;

procedure SetConsumerFeatures(Disable: Boolean; LogMemo: TMemo);
const
  CloudContentKey = 'SOFTWARE\Policies\Microsoft\Windows\CloudContent';
var
  Reg: TRegistry;
  Value: Integer;
begin
  Reg := TRegistry.Create(KEY_ALL_ACCESS or KEY_WOW64_64KEY);
  try
    Reg.RootKey := HKEY_LOCAL_MACHINE;
    if Reg.OpenKey(CloudContentKey, True) then
    begin
      if Disable then
      begin
        Value := 1;
        Reg.WriteInteger('DisableConsumerFeatures', Value);
        LogMemo.Lines.Add('Consumer Features have been disabled.');
      end
      else
      begin
        Value := 0;
        Reg.WriteInteger('DisableConsumerFeatures', Value);
        LogMemo.Lines.Add('Consumer Features have been enabled.');
      end;
      Reg.CloseKey;
    end
    else
      LogMemo.Lines.Add('Failed to open registry key: ' + CloudContentKey);
  except
    on E: Exception do
      LogMemo.Lines.Add('Error setting Consumer Features: ' + E.Message);
  end;
  Reg.Free;
  LogMemo.Lines.Add('Changes may require a restart to take effect.');
end;
//procedure RunPowerShellCommand(const CmdLine: string; LogMemo: TMemo);
//var
//  sei: TShellExecuteInfo;
//  ExitCode: DWORD;
//begin
//  FillChar(sei, SizeOf(sei), 0);
//  sei.cbSize := SizeOf(sei);
//  // Use SEE_MASK_NOCLOSEPROCESS so we can wait on the process handle.
//  sei.fMask := SEE_MASK_NOCLOSEPROCESS or SEE_MASK_FLAG_NO_UI;
//  sei.lpVerb := 'runas'; // Run as administrator (will trigger UAC prompt if needed)
//  sei.lpFile := 'PowerShell.exe';
//  // Build the parameters string: -NoProfile to avoid loading user profile,
//  // and run our command in quotes.
//  sei.lpParameters := PChar('-NoProfile -Command "' + CmdLine + '"');
//  // Set nShow to SW_HIDE to hide the window.
//  sei.nShow := SW_HIDE;
//  if ShellExecuteEx(@sei) then
//  begin
//    // Wait until the command finishes.
//    WaitForSingleObject(sei.hProcess, INFINITE);
//    if GetExitCodeProcess(sei.hProcess, ExitCode) then
//      LogMemo.Lines.Add(Format('Command "%s" completed with exit code %d.', [CmdLine, ExitCode]))
//    else
//      LogMemo.Lines.Add(Format('Command "%s" completed but exit code not retrieved.', [CmdLine]));
//    CloseHandle(sei.hProcess);
//  end
//  else
//    LogMemo.Lines.Add(Format('Failed to run command: "%s". Error code: %d', [CmdLine, GetLastError]));
//end;

procedure DisableWindowsDefender(LogMemo: TMemo);
begin
  RunPowerShellCommand('Set-MpPreference -DisableRealtimeMonitoring $true', LogMemo);
end;

procedure EnableWindowsDefender(LogMemo: TMemo);
begin
  RunPowerShellCommand('Set-MpPreference -DisableRealtimeMonitoring $false', LogMemo);
end;

procedure DisableWindowsUpdate(LogMemo: TMemo);
begin
  RunPowerShellCommand('Set-Service -Name wuauserv -StartupType Disabled; Stop-Service -Name wuauserv -Force', LogMemo);
end;


procedure EnableWindowsUpdate(LogMemo: TMemo);
begin
  RunPowerShellCommand('Set-Service -Name wuauserv -StartupType Automatic; Start-Service -Name wuauserv', LogMemo);
end;




procedure SetRecentItemsHistory(Enable: Boolean; LogMemo: TMemo);
const
  KeyPath = 'Software\Microsoft\Windows\CurrentVersion\Policies\Explorer';
var
  Reg: TRegistry;
begin
  Reg := TRegistry.Create(KEY_ALL_ACCESS);
  try
    Reg.RootKey := HKEY_CURRENT_USER;
    if Reg.OpenKey(KeyPath, True) then
    begin
      if Enable then
      begin
        if Reg.ValueExists('NoRecentDocsHistory') then
          Reg.DeleteValue('NoRecentDocsHistory');
        if Reg.ValueExists('NoRecentDocsMenu') then
          Reg.DeleteValue('NoRecentDocsMenu');
        LogMemo.Lines.Add('Recent items history has been enabled.');
      end
      else
      begin
        Reg.WriteInteger('NoRecentDocsHistory', 1);
        Reg.WriteInteger('NoRecentDocsMenu', 1);
        LogMemo.Lines.Add('Recent items history has been disabled.');
      end;
      Reg.CloseKey;
    end
    else
      LogMemo.Lines.Add('Failed to open key: ' + KeyPath);
  except
    on E: Exception do
      LogMemo.Lines.Add('Error setting recent items history: ' + E.Message);
  end;
  Reg.Free;

  // Broadcast a settings change so that Explorer refreshes its UI.
  PostMessage(HWND_BROADCAST, WM_SETTINGCHANGE, 0,
    LPARAM(PChar(KeyPath)));
  LogMemo.Lines.Add('WM_SETTINGCHANGE message posted.');
end;


//procedure DisableWindowsDefender(LogMemo: TMemo);
//begin
//  // This PowerShell command disables real-time monitoring.
//  RunPowerShellCommand('Set-MpPreference -DisableRealtimeMonitoring $true', LogMemo);
//end;
//
//procedure EnableWindowsDefender(LogMemo: TMemo);
//begin
//  RunPowerShellCommand('Set-MpPreference -DisableRealtimeMonitoring $false', LogMemo);
//end;




procedure RunCommand(const CmdLine: string; LogMemo: TMemo);
var
  StartupInfo: TStartupInfo;
  ProcessInfo: TProcessInformation;
  Cmd: string;
  ExitCode: DWORD;
begin
  FillChar(StartupInfo, SizeOf(StartupInfo), 0);
  StartupInfo.cb := SizeOf(StartupInfo);
  // Build the command to run in cmd.exe
  // The /c switch tells cmd.exe to run the command and then terminate.
  Cmd := 'cmd.exe /c ' + CmdLine;
  if CreateProcess(nil, PChar(Cmd), nil, nil, False, 0, nil, nil, StartupInfo, ProcessInfo) then
  begin
    // Wait until the command finishes
    WaitForSingleObject(ProcessInfo.hProcess, INFINITE);
    if GetExitCodeProcess(ProcessInfo.hProcess, ExitCode) then
      LogMemo.Lines.Add(Format('Command "%s" completed with exit code %d.', [CmdLine, ExitCode]))
    else
      LogMemo.Lines.Add(Format('Command "%s" completed but exit code could not be retrieved.', [CmdLine]));
    CloseHandle(ProcessInfo.hProcess);
    CloseHandle(ProcessInfo.hThread);
  end
  else
    LogMemo.Lines.Add(Format('Failed to run command: "%s".', [CmdLine]));
end;

procedure RepairSystemFiles(LogMemo: TMemo);
begin
  LogMemo.Lines.Add('Starting DISM repair...');
  RunCommand('DISM /Online /Cleanup-image /Restorehealth', LogMemo);

  LogMemo.Lines.Add('Starting SFC scan...');
  RunCommand('sfc /scannow', LogMemo);

  LogMemo.Lines.Add('System repair commands completed. Please restart your computer if required.');
end;

procedure SetDarkMode(EnableDark: Boolean; LogMemo: TMemo);
var
  Reg: TRegistry;
  Value: Integer;
begin
  Reg := TRegistry.Create(KEY_READ or KEY_WRITE);
  try
    Reg.RootKey := HKEY_CURRENT_USER;
    if Reg.OpenKey('Software\Microsoft\Windows\CurrentVersion\Themes\Personalize', True) then
    begin
      // For dark mode, set value to 0; for light mode, set to 1.
      if EnableDark then
      begin
        Value := 0;
        Reg.WriteInteger('AppsUseLightTheme', Value);
        Reg.WriteInteger('SystemUsesLightTheme', Value);
        LogMemo.Lines.Add('Dark mode has been enabled.');
      end
      else
      begin
        Value := 1;
        Reg.WriteInteger('AppsUseLightTheme', Value);
        Reg.WriteInteger('SystemUsesLightTheme', Value);
        LogMemo.Lines.Add('Dark mode has been disabled (light mode enabled).');
      end;
      Reg.CloseKey;
    end
    else
      LogMemo.Lines.Add('Failed to open registry key for theme personalization.');
  except
    on E: Exception do
      LogMemo.Lines.Add('Error setting dark mode: ' + E.Message);
  end;
  Reg.Free;

  // Notify the system that settings have changed so that the change is applied immediately.
  SendMessage(HWND_BROADCAST, WM_SETTINGCHANGE, 0, LPARAM(PChar('ImmersiveColorSet')));
  LogMemo.Lines.Add('Broadcast WM_SETTINGCHANGE sent.');
end;


procedure OpenBackgroundAppsSettings;
begin
  // "ms-settings:privacy-backgroundapps" opens the Background Apps settings page.
  if ShellExecute(0, 'open', 'ms-settings:privacy-backgroundapps', nil, nil, SW_SHOWNORMAL) <= 32 then
    raise Exception.Create('Failed to open Background Apps settings.');
end;

procedure AdjustForBestPerformance(LogMemo: TMemo);
var
  Reg: TRegistry;
  Buffer: TBytes;
begin
  Reg := TRegistry.Create(KEY_READ or KEY_WRITE);
  try
    Reg.RootKey := HKEY_CURRENT_USER;
    if Reg.OpenKey('Control Panel\Desktop', False) then
    begin
      // Set the UserPreferencesMask to a value that disables most visual effects.
      // Note: This value may vary by OS version. The value below is one commonly
      // used for "Adjust for best performance" on some Windows versions.
      Buffer := [$90, $12, $03, $80, $10, $00, $00, $00];
      Reg.WriteBinaryData('UserPreferencesMask', Buffer[0], Length(Buffer));
      LogMemo.Lines.Add('Visual effects set to "Adjust for best performance" via UserPreferencesMask.');
      Reg.CloseKey;
    end
    else
      LogMemo.Lines.Add('Failed to open HKCU\Control Panel\Desktop.');
  except
    on E: Exception do
      LogMemo.Lines.Add('Error setting UserPreferencesMask: ' + E.Message);
  end;
  Reg.Free;

  // Notify Windows and running applications that a system setting has changed.
  SendMessage(HWND_BROADCAST, WM_SETTINGCHANGE, 0, LPARAM(PChar('WindowMetrics')));
  LogMemo.Lines.Add('Broadcast WM_SETTINGCHANGE sent.');
end;


procedure SetShowHiddenFiles(ShowHidden, ShowProtectedOSFiles: Boolean; LogMemo: TMemo);
var
  Reg: TRegistry;
  HiddenValue, SuperHiddenValue: Integer;
begin
  Reg := TRegistry.Create(KEY_READ or KEY_WRITE);
  try
    Reg.RootKey := HKEY_CURRENT_USER;
    if Reg.OpenKey('Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced', True) then
    begin
      // Hidden: 1 = show hidden files, 2 = do not show.
      if ShowHidden then
        HiddenValue := 1
      else
        HiddenValue := 2;
      Reg.WriteInteger('Hidden', HiddenValue);

      // ShowSuperHidden: 1 = show protected OS files, 0 = hide them.
      if ShowProtectedOSFiles then
        SuperHiddenValue := 1
      else
        SuperHiddenValue := 0;
      Reg.WriteInteger('ShowSuperHidden', SuperHiddenValue);

      LogMemo.Lines.Add(Format('Explorer settings updated: Hidden=%d, ShowSuperHidden=%d',
        [HiddenValue, SuperHiddenValue]));
      Reg.CloseKey;
    end
    else
      LogMemo.Lines.Add('Failed to open Explorer Advanced key.');
  except
    on E: Exception do
      LogMemo.Lines.Add('Error setting Explorer settings: ' + E.Message);
  end;
  Reg.Free;

  // Use PostMessage to avoid UI hang (non-blocking)
  PostMessage(HWND_BROADCAST, WM_SETTINGCHANGE, 0,
    LPARAM(PChar('Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced')));
  LogMemo.Lines.Add('WM_SETTINGCHANGE broadcast sent via PostMessage.');
end;


procedure CreateGodModeFolder;
var
  DesktopPath, FolderPath: string;
begin
  DesktopPath := IncludeTrailingPathDelimiter(GetEnvironmentVariable('USERPROFILE')) + 'Desktop';
  FolderPath := IncludeTrailingPathDelimiter(DesktopPath) + 'GodMode.{ED7BA470-8E54-465E-825C-99712043E01C}';
  if not TDirectory.Exists(FolderPath) then
  begin
    ForceDirectories(FolderPath);
    Application.MessageBox(PChar('God Mode folder created at: ' + FolderPath), 'God Mode Enabled', MB_OK);
  end
  else
    Application.MessageBox(PChar('God Mode folder already exists at: ' + FolderPath), 'God Mode', MB_OK);
end;

procedure EnableFastStartup(LogMemo: TMemo);
const
  PowerKeyPath = 'SYSTEM\CurrentControlSet\Control\Session Manager\Power';
var
  Reg: TRegistry;
  Value: Integer;
begin
  Reg := TRegistry.Create(KEY_READ or KEY_WRITE or KEY_WOW64_64KEY);
  try
    Reg.RootKey := HKEY_LOCAL_MACHINE;
    if Reg.OpenKey(PowerKeyPath, True) then
    begin
      // Set the "HiberbootEnabled" value to 1 to enable Fast Startup.
      Reg.WriteInteger('HiberbootEnabled', 1);
      LogMemo.Lines.Add('Fast Startup has been enabled.');
      // Read back to verify
      if Reg.ValueExists('HiberbootEnabled') then
      begin
        Value := Reg.ReadInteger('HiberbootEnabled');
        LogMemo.Lines.Add(Format('Verification: HiberbootEnabled = %d', [Value]));
      end
      else
        LogMemo.Lines.Add('Verification failed: HiberbootEnabled not found.');
      Reg.CloseKey;
    end
    else
      LogMemo.Lines.Add('Failed to open key: ' + PowerKeyPath);
  except
    on E: Exception do
      LogMemo.Lines.Add('Error enabling Fast Startup: ' + E.Message);
  end;
  Reg.Free;
  LogMemo.Lines.Add('Note: Changes will take effect after a complete shutdown and restart.');
end;

procedure EnableStorageSense(LogMemo: TMemo);
const
  KeyPath = 'Software\Microsoft\Windows\CurrentVersion\StorageSense\Parameters\StoragePolicy';
var
  Reg: TRegistry;
  Value: Integer;
begin
  Reg := TRegistry.Create(KEY_READ or KEY_WRITE);
  try
    Reg.RootKey := HKEY_CURRENT_USER;
    if Reg.OpenKey(KeyPath, True) then
    begin
      // Set StorageSenseEnabled to 1 to enable Storage Sense.
      Reg.WriteInteger('StorageSenseEnabled', 1);
      // Optionally, you could configure other settings, for example:
      // Reg.WriteInteger('CleanupThresholdDays', 30);  // Clean up if files older than 30 days
      LogMemo.Lines.Add('Storage Sense has been enabled.');
      Reg.CloseKey;
    end
    else
      LogMemo.Lines.Add('Failed to open key: ' + KeyPath);
  except
    on E: Exception do
      LogMemo.Lines.Add('Error enabling Storage Sense: ' + E.Message);
  end;
  Reg.Free;

  // Notify Windows that settings have changed.
  SendMessage(HWND_BROADCAST, WM_SETTINGCHANGE, 0, LPARAM(PChar('StorageSense')));
  LogMemo.Lines.Add('WM_SETTINGCHANGE broadcast sent for Storage Sense.');
end;

procedure DisableStorageSense(LogMemo: TMemo);
const
  KeyPath = 'Software\Microsoft\Windows\CurrentVersion\StorageSense\Parameters\StoragePolicy';
var
  Reg: TRegistry;
begin
  Reg := TRegistry.Create(KEY_READ or KEY_WRITE);
  try
    Reg.RootKey := HKEY_CURRENT_USER;
    if Reg.OpenKey(KeyPath, True) then
    begin
      Reg.WriteInteger('StorageSenseEnabled', 0);
      LogMemo.Lines.Add('Storage Sense has been disabled.');
      Reg.CloseKey;
    end
    else
      LogMemo.Lines.Add('Failed to open key: ' + KeyPath);
  except
    on E: Exception do
      LogMemo.Lines.Add('Error disabling Storage Sense: ' + E.Message);
  end;
  Reg.Free;
  SendMessage(HWND_BROADCAST, WM_SETTINGCHANGE, 0, LPARAM(PChar('StorageSense')));
  LogMemo.Lines.Add('WM_SETTINGCHANGE broadcast sent for Storage Sense.');
end;

procedure DisableBackgroundApps(LogMemo: TMemo);
var
  Reg: TRegistry;
  Value: Integer;
begin
  Reg := TRegistry.Create(KEY_READ or KEY_WRITE);
  try
    Reg.RootKey := HKEY_CURRENT_USER;
    if Reg.OpenKey('Software\Microsoft\Windows\CurrentVersion\BackgroundAccessApplications', True) then
    begin
      // Set GlobalUserDisabled to 1 to disable background apps.
      Reg.WriteInteger('GlobalUserDisabled', 1);
      LogMemo.Lines.Add('Background apps have been disabled.');

      // Verify the change.
      Value := Reg.ReadInteger('GlobalUserDisabled');
      if Value = 1 then
        LogMemo.Lines.Add('Verification: GlobalUserDisabled = 1.')
      else
        LogMemo.Lines.Add('Verification: GlobalUserDisabled is not 1 (value: ' + IntToStr(Value) + ').');

      Reg.CloseKey;
    end
    else
      LogMemo.Lines.Add('Failed to open the BackgroundAccessApplications registry key.');
  except
    on E: Exception do
      LogMemo.Lines.Add('Error disabling background apps: ' + E.Message);
  end;
  Reg.Free;
end;

procedure LoadTaskWhitelist(const IniPath: string; Whitelist: TStringList);
var
  Ini: TIniFile;
  Count, i: Integer;
  TaskName: string;
begin
  Whitelist.Clear;
  if not FileExists(IniPath) then
  begin
    // Default whitelist (essential tasks that you don't want to disable)
    Whitelist.Add('Microsoft\Windows\Defrag');
    Whitelist.Add('Microsoft\Windows\TaskScheduler');
    Whitelist.Add('Microsoft\Windows\Time Synchronization');
    Whitelist.Add('Microsoft\Windows\WindowsUpdate');
    // Save these defaults to the INI file for future editing.
    Ini := TIniFile.Create(IniPath);
    try
      Ini.WriteInteger('Whitelist', 'Count', Whitelist.Count);
      for i := 0 to Whitelist.Count - 1 do
        Ini.WriteString('Whitelist', 'Task' + IntToStr(i), Whitelist[i]);
    finally
      Ini.Free;
    end;
  end
  else
  begin
    Ini := TIniFile.Create(IniPath);
    try
      Count := Ini.ReadInteger('Whitelist', 'Count', 0);
      for i := 0 to Count - 1 do
      begin
        TaskName := Ini.ReadString('Whitelist', 'Task' + IntToStr(i), '');
        if TaskName <> '' then
          Whitelist.Add(TaskName);
      end;
    finally
      Ini.Free;
    end;
  end;
end;




procedure DisableUnnecessaryScheduledTasks(LogMemo: TMemo);
var
  TaskService, RootFolder, Tasks, Task: OLEVariant;
  i: Integer;
  TaskName: string;
  Whitelist: TStringList;
  IniPath: string;
begin
  Whitelist := TStringList.Create;
  try
    // Determine INI file path (same directory as EXE)
    IniPath := ExtractFilePath(ParamStr(0)) + 'TaskWhitelist.ini';
    LoadTaskWhitelist(IniPath, Whitelist);

    try
      // Create and connect to the Task Scheduler service
      TaskService := CreateOleObject('Schedule.Service');
      TaskService.Connect;
      // Get the root folder (tasks in the root folder)
      RootFolder := TaskService.GetFolder('\');
      // Get all tasks in the root folder (0 = no flags)
      Tasks := RootFolder.GetTasks(0);
      // Note: Task collections in Task Scheduler are 1-indexed.
      for i := 1 to Tasks.Count do
      begin
        Task := Tasks.Item[i];
        TaskName := VarToStr(Task.Name);
        // If the task is not in the whitelist, disable it.
        if Whitelist.IndexOf(TaskName) = -1 then
        begin
          if Task.Enabled then
          begin
            try
              Task.Enabled := False;
              LogMemo.Lines.Add(Format('Task "%s" disabled.', [TaskName]));
            except
              on E: Exception do
                LogMemo.Lines.Add(Format('Failed to disable task "%s": %s', [TaskName, E.Message]));
            end;
          end;
        end
        else
          LogMemo.Lines.Add(Format('Task "%s" is whitelisted and left enabled.', [TaskName]));
      end;
    except
      on E: Exception do
        LogMemo.Lines.Add('Error in scheduled tasks optimization: ' + E.Message);
    end;
  finally
    Whitelist.Free;
  end;
end;





procedure DisableSysMain(LogMemo: TMemo);
var
  WbemLocator, WMIService, Services, Service: OLEVariant;
  FetchedCount: Cardinal;
begin
  try
    // Create the WMI locator and connect to the CIMV2 namespace
    WbemLocator := CreateOleObject('WbemScripting.SWbemLocator');
    WMIService := WbemLocator.ConnectServer('.', 'root\CIMV2');
    // Query for the SysMain service (Superfetch in older systems)
    Services := WMIService.ExecQuery('SELECT * FROM Win32_Service WHERE Name="SysMain"');
    // Try to get the service object
    if VarIsNull(Services) then
    begin
      LogMemo.Lines.Add('SysMain service not found.');
      Exit;
    end;
    Service := Unassigned;
    if (IInterface(Services._NewEnum) <> nil) and (Services.Count > 0) then
    begin
      // Retrieve the first (and should be only) service
      if (IUnknown(Services._NewEnum) as IEnumVariant).Next(1, Service, FetchedCount) = 0 then
      begin
        // Check current start mode
        if VarToStr(Service.StartMode) <> 'Disabled' then
        begin
          Service.ChangeStartMode('Disabled');
          LogMemo.Lines.Add('SysMain service disabled successfully.');
        end
        else
          LogMemo.Lines.Add('SysMain service is already disabled.');
      end
      else
        LogMemo.Lines.Add('SysMain service not found.');
    end
    else
      LogMemo.Lines.Add('SysMain service not found.');
  except
    on E: Exception do
      LogMemo.Lines.Add('Error disabling SysMain: ' + E.Message);
  end;
end;




procedure DeleteFilesInDirectory(const Dir: string; LogMemo: TMemo);
var
  Files: TArray<string>;
  SubDirs: TArray<string>;
  FileName: string;
begin
  if not TDirectory.Exists(Dir) then Exit;
  try
    // Delete files
    Files := TDirectory.GetFiles(Dir);
    for FileName in Files do
    begin
      try
        TFile.Delete(FileName);
        LogMemo.Lines.Add(Format('Deleted file: %s', [FileName]));
      except
        on E: Exception do
          LogMemo.Lines.Add(Format('Failed to delete file %s: %s', [FileName, E.Message]));
      end;
    end;
    // Delete subdirectories recursively
    SubDirs := TDirectory.GetDirectories(Dir);
    for FileName in SubDirs do
    begin
      try
        TDirectory.Delete(FileName, True);
        LogMemo.Lines.Add(Format('Deleted directory: %s', [FileName]));
      except
        on E: Exception do
          LogMemo.Lines.Add(Format('Failed to delete directory %s: %s', [FileName, E.Message]));
      end;
    end;
  except
    on E: Exception do
      LogMemo.Lines.Add(Format('Error cleaning directory %s: %s', [Dir, E.Message]));
  end;
end;

procedure EmptyRecycleBin(LogMemo: TMemo);
var
  hr: HRESULT;
begin
  // Flags: no confirmation, no progress UI, no sound
  hr := SHEmptyRecycleBin(0, nil, SHERB_NOCONFIRMATION or SHERB_NOPROGRESSUI or SHERB_NOSOUND);
  if Succeeded(hr) then
    LogMemo.Lines.Add('Recycle Bin emptied successfully.')
  else
    LogMemo.Lines.Add(Format('Failed to empty Recycle Bin. HRESULT: $%.8x', [hr]));
end;

procedure CleanUpTemporaryFilesAndCaches(LogMemo: TMemo);
var
  TempPath, WindowsTemp: string;
  WindowsDir: array[0..MAX_PATH] of Char;
begin
  // Clean the current user's temporary folder
  TempPath := GetEnvironmentVariable('TEMP');
  if TempPath = '' then
  begin
    GetTempPath(MAX_PATH, WindowsDir);
    TempPath := WindowsDir; // Convert the buffer to string
  end;
  if TempPath <> '' then
  begin
    LogMemo.Lines.Add('Cleaning temporary files in: ' + TempPath);
    DeleteFilesInDirectory(TempPath, LogMemo);
  end
  else
    LogMemo.Lines.Add('Could not determine TEMP directory.');

  // Clean the Windows\Temp folder (requires administrative privileges)
  if GetWindowsDirectory(WindowsDir, MAX_PATH) <> 0 then
  begin
    WindowsTemp := IncludeTrailingPathDelimiter(WindowsDir) + 'Temp';
    if TDirectory.Exists(WindowsTemp) then
    begin
      LogMemo.Lines.Add('Cleaning Windows Temp files in: ' + WindowsTemp);
      DeleteFilesInDirectory(WindowsTemp, LogMemo);
    end
    else
      LogMemo.Lines.Add('Windows Temp folder not found.');
  end;

  // Empty the Recycle Bin
  EmptyRecycleBin(LogMemo);

  LogMemo.Lines.Add('Temporary files and caches cleanup complete.');
end;


procedure DisableWindowsSearchIndexing(LogMemo: TMemo);
var
  WbemLocator, WMIService, Services, Service: OLEVariant;
  Enum: IEnumVariant;
  FetchedCount: Cardinal;
begin
  try
    // Connect to WMI
    WbemLocator := CreateOleObject('WbemScripting.SWbemLocator');
    WMIService := WbemLocator.ConnectServer('.', 'root\CIMV2');
    // Query the Windows Search service ("WSearch")
    Services := WMIService.ExecQuery('SELECT * FROM Win32_Service WHERE Name="WSearch"');
    Enum := IUnknown(Services._NewEnum) as IEnumVariant;
    if Enum.Next(1, Service, FetchedCount) = 0 then
    begin
      // Check current start mode
      if VarToStr(Service.StartMode) <> 'Disabled' then
      begin
        Service.ChangeStartMode('Disabled');
        LogMemo.Lines.Add('Windows Search Indexing service (WSearch) disabled.');
      end
      else
        LogMemo.Lines.Add('Windows Search Indexing service (WSearch) is already disabled.');
    end
    else
      LogMemo.Lines.Add('Windows Search service (WSearch) not found.');
  except
    on E: Exception do
      LogMemo.Lines.Add('Error disabling Windows Search Indexing: ' + E.Message);
  end;
end;



 {=== Service Optimization ===}

procedure SetNonEssentialServicesToManual(Whitelist: TStringList; LogMemo: TMemo);
var
  WbemLocator, WMIService, Services, Service: OLEVariant;
  Enum: IEnumVariant;
  FetchedCount: Cardinal;
  ServiceName, StartMode: string;
begin
  try
    // Connect to WMI
    WbemLocator := CreateOleObject('WbemScripting.SWbemLocator');
    WMIService := WbemLocator.ConnectServer('.', 'root\CIMV2');
    // Query all services
    Services := WMIService.ExecQuery('SELECT Name, StartMode FROM Win32_Service');
    Enum := IUnknown(Services._NewEnum) as IEnumVariant;
    while Enum.Next(1, Service, FetchedCount) = 0 do
    begin
      ServiceName := VarToStr(Service.Name);
      StartMode := VarToStr(Service.StartMode);
      // If the service is not in the whitelist and its start mode is not already Manual...
      if Whitelist.IndexOf(ServiceName) = -1 then
      begin
        if not SameText(StartMode, 'Manual') then
        begin
          try
            // Change the service start mode to Manual.
            Service.ChangeStartMode('Manual');
            LogMemo.Lines.Add(Format('Service "%s" changed from %s to Manual.', [ServiceName, StartMode]));
          except
            on E: Exception do
              LogMemo.Lines.Add(Format('Error changing start mode for "%s": %s', [ServiceName, E.Message]));
          end;
        end;
      end;
      Service := Unassigned;
    end;
  except
    on E: Exception do
      LogMemo.Lines.Add('Error accessing services via WMI: ' + E.Message);
  end;
end;

procedure LoadServiceWhitelist(var Whitelist: TStringList);
var
  Ini: TIniFile;
  IniPath: string;
  i, Count: Integer;
  ServiceName: string;
begin
  Whitelist.Clear;
  IniPath := ExtractFilePath(ParamStr(0)) + 'ServiceWhitelist.ini';
  if not FileExists(IniPath) then
  begin
    // Create a default whitelist of essential services
    // (You can adjust this list as needed)
    Whitelist.Add('RpcSs');         // Remote Procedure Call (RPC)
    Whitelist.Add('DcomLaunch');      // DCOM Server Process Launcher
    Whitelist.Add('RpcEptMapper');    // RPC Endpoint Mapper
    Whitelist.Add('PlugPlay');        // Plug and Play
    Whitelist.Add('Winmgmt');         // Windows Management Instrumentation
    Whitelist.Add('EventLog');        // Windows Event Log
    Whitelist.Add('Schedule');        // Task Scheduler
    Whitelist.Add('EventSystem');     // COM+ Event System

    // Add critical user services:
    Whitelist.Add('Audiosrv');              // Windows Audio
    Whitelist.Add('AudioEndpointBuilder');    // Audio Endpoint Builder
    Whitelist.Add('WlanSvc');                 // Wi-Fi AutoConfig


    // Save these defaults to the INI file for future use
    Ini := TIniFile.Create(IniPath);
    try
      Ini.WriteInteger('Whitelist', 'Count', Whitelist.Count);
      for i := 0 to Whitelist.Count - 1 do
        Ini.WriteString('Whitelist', 'Service' + IntToStr(i), Whitelist[i]);
    finally
      Ini.Free;
    end;
  end
  else
  begin
    Ini := TIniFile.Create(IniPath);
    try
      Count := Ini.ReadInteger('Whitelist', 'Count', 0);
      for i := 0 to Count - 1 do
      begin
        ServiceName := Ini.ReadString('Whitelist', 'Service' + IntToStr(i), '');
        if ServiceName <> '' then
          Whitelist.Add(ServiceName);
      end;
    finally
      Ini.Free;
    end;
  end;
end;




const
  // High Performance power plan GUID:
  GUID_HIGH_PERFORMANCE: TGUID = '{8c5e7fda-e8bf-4a96-9a85-a6e23a8c635c}';

function PowerSetActiveScheme(UserPowerKey: HKEY; const PowerSchemeGuid: PGUID): DWORD; stdcall; external 'powrprof.dll';

procedure SetHighPerformancePowerPlan(LogMemo: TMemo);
var
  res: DWORD;
begin
  // Initialize ProgressBar2
  form3.ProgressBar2.Min := 0;
  form3.ProgressBar2.Max := 100;
  form3.ProgressBar2.Position := 0;
  Application.ProcessMessages;

  LogMemo.Lines.Add('Attempting to set High Performance power plan...');
  // Update progress to 30% before the main call
  form3.ProgressBar2.Position := 30;
  Application.ProcessMessages;

  // Attempt to set the active power scheme to High Performance
  res := PowerSetActiveScheme(0, @GUID_HIGH_PERFORMANCE);

  // Update progress to 70% after the call returns
  form3.ProgressBar2.Position := 70;
  Application.ProcessMessages;

  if res = ERROR_SUCCESS then
    LogMemo.Lines.Add('High performance power plan activated successfully.')
  else
    LogMemo.Lines.Add(Format('Failed to activate high performance power plan. Error: %d - %s',
      [res, SysErrorMessage(res)]));

  // Final update to complete the operation
  form3.ProgressBar2.Position := 100;
  Application.ProcessMessages;
end;



procedure OptimizeVisualEffects(LogMemo: TMemo);
var
  AnimInfo: ANIMATIONINFO;
begin
  // Initialize ProgressBar2 on Form3
  Form3.ProgressBar2.Min := 0;
  Form3.ProgressBar2.Max := 100;
  Form3.ProgressBar2.Position := 0;
  Application.ProcessMessages;

  // Initialize the structure for setting animation info.
  AnimInfo.cbSize := SizeOf(ANIMATIONINFO);
  AnimInfo.iMinAnimate := 0; // disable animations

  // Attempt to disable window animations.
  if SystemParametersInfo(SPI_SETANIMATION, AnimInfo.cbSize, @AnimInfo,
      SPIF_UPDATEINIFILE or SPIF_SENDWININICHANGE) then
    LogMemo.Lines.Add('Successfully disabled window animations.')
  else
    LogMemo.Lines.Add('Failed to disable window animations: ' + SysErrorMessage(GetLastError));

  // Update progress to 50% after attempting to disable animations.
  Form3.ProgressBar2.Position := 50;
  Application.ProcessMessages;

  // Now check the current animation settings.
  FillChar(AnimInfo, SizeOf(AnimInfo), 0);
  AnimInfo.cbSize := SizeOf(ANIMATIONINFO);
  if SystemParametersInfo(SPI_GETANIMATION, AnimInfo.cbSize, @AnimInfo, 0) then
  begin
    if AnimInfo.iMinAnimate = 0 then
      LogMemo.Lines.Add('Visual effects are disabled (iMinAnimate = 0).')
    else
      LogMemo.Lines.Add(Format('Visual effects are enabled (iMinAnimate = %d).', [AnimInfo.iMinAnimate]));
  end
  else
    LogMemo.Lines.Add('Failed to read visual effects settings: ' + SysErrorMessage(GetLastError));

  // Final update to indicate completion.
  Form3.ProgressBar2.Position := 100;
  Application.ProcessMessages;
end;


procedure EnsureCustomHKLMDisabledKeyExists;
var
  Reg: TRegistry;
begin
  Reg := TRegistry.Create(KEY_READ or KEY_WRITE or KEY_WOW64_64KEY);
  try
    Reg.RootKey := HKEY_LOCAL_MACHINE;
    // Check if the custom key exists; if not, try to create it.
    if not Reg.KeyExists(CustomStartupDisabledKey_LM) then
    begin
      if not Reg.OpenKey(CustomStartupDisabledKey_LM, True) then
        raise Exception.CreateFmt('Failed to create custom key %s', [CustomStartupDisabledKey_LM]);
      Reg.CloseKey;
    end;
  finally
    Reg.Free;
  end;
end;



   procedure EnsureKeyExists(Root: HKEY; const KeyPath: string; RegFlags: DWORD);
var
  Reg: TRegistry;
begin
  Reg := TRegistry.Create(KEY_READ or KEY_WRITE or RegFlags);
  try
    Reg.RootKey := Root;
    if not Reg.KeyExists(KeyPath) then
    begin
      if not Reg.OpenKey(KeyPath, True) then
        raise Exception.CreateFmt('Failed to create key %s', [KeyPath]);
      Reg.CloseKey;
    end;
  finally
    Reg.Free;
  end;
end;



  procedure EnumerateStartupKey(const KeyInfo: TStartupKeyInfo; const RegFlags: DWORD;
  ListView: TListView; LogMemo: TMemo);
var
  Reg: TRegistry;
  Names: TStringList;
  i: Integer;
  AppName, AppCmd, Status, ViewStr: string;
  ListItem: TListItem;
begin
  Names := TStringList.Create;
  Reg := TRegistry.Create(KEY_READ or RegFlags);
  try
    Reg.RootKey := KeyInfo.Root;
    // Only proceed if the key exists
    if not Reg.KeyExists(KeyInfo.KeyPath) then
    begin
      // Optionally log that the key does not exist.
      LogMemo.Lines.Add('Key does not exist: ' + KeyInfo.Source);
      Exit;
    end;

    if Reg.OpenKeyReadOnly(KeyInfo.KeyPath) then
    begin
      Reg.GetValueNames(Names);
      for i := 0 to Names.Count - 1 do
      begin
        AppName := Names[i];
        try
          AppCmd := Reg.ReadString(AppName);
        except
          on E: Exception do
          begin
            AppCmd := '';
            LogMemo.Lines.Add(Format('Error reading %s in %s: %s', [AppName, KeyInfo.Source, E.Message]));
          end;
        end;
        if KeyInfo.IsDisabled then
          Status := 'Disabled'
        else
          Status := 'Enabled';
        if RegFlags = KEY_WOW64_64KEY then
          ViewStr := '64-bit'
        else if RegFlags = KEY_WOW64_32KEY then
          ViewStr := '32-bit'
        else
          ViewStr := 'Unknown';

        ListItem := ListView.Items.Add;
        ListItem.Caption := AppName;
        ListItem.SubItems.Add(AppCmd);
        ListItem.SubItems.Add(Status);
        ListItem.SubItems.Add(KeyInfo.Source);
        ListItem.SubItems.Add(ViewStr);
        // Mark enabled items as checked.
        ListItem.Checked := not KeyInfo.IsDisabled;
      end;
      Reg.CloseKey;
    end
    else
      LogMemo.Lines.Add('Unable to open key: ' + KeyInfo.Source);
  except
    on E: Exception do
      LogMemo.Lines.Add(Format('Error reading key %s: %s', [KeyInfo.Source, E.Message]));
  end;
  Reg.Free;
  Names.Free;
end;




  {*
  Toggles the startup state for a given application.
  Moves the registry value from the "enabled" key to the "disabled" key or vice versa,
  based on the Enable flag. The Scope parameter must be either 'HKCU' or 'HKLM'.
*}
procedure ToggleStartupAppExtended(const AppName: string; Enable: Boolean; const ScopeFull: string; LogMemo: TMemo);
var
  Reg: TRegistry;
  AppCmd: string;
  SourceKey, DestKey: string;
  Scope: string;
  RegFlags: DWORD;
  Root: HKEY;
begin
  // Determine the root and registry flags based on the scope.
  Scope := ExtractScope(ScopeFull);
  if Scope = 'HKCU' then
  begin
    Root := HKEY_CURRENT_USER;
    RegFlags := KEY_WOW64_64KEY; // adjust if needed
    if Enable then
    begin
      SourceKey := StartupDisabledKey_CU;
      DestKey := StartupKey_CU;
    end
    else
    begin
      SourceKey := StartupKey_CU;
      DestKey := StartupDisabledKey_CU;
    end;
  end
  else if Scope = 'HKLM' then
  begin
    Root := HKEY_LOCAL_MACHINE;
    RegFlags := KEY_WOW64_64KEY; // adjust if needed
    if Enable then
    begin
      // For HKLM, use our custom disabled key
      SourceKey := CustomStartupDisabledKey_LM;
      DestKey := StartupKey_LM;
    end
    else
    begin
      SourceKey := StartupKey_LM;
      DestKey := CustomStartupDisabledKey_LM;
      // Ensure our custom key exists
      try
        EnsureCustomHKLMDisabledKeyExists;
      except
        on E: Exception do
        begin
          LogMemo.Lines.Add('Error ensuring custom HKLM disabled key exists: ' + E.Message);
          Exit;
        end;
      end;
    end;
  end
  else
  begin
    LogMemo.Lines.Add('Unknown scope for startup app: ' + ScopeFull);
    Exit;
  end;

  Reg := TRegistry.Create(KEY_READ or KEY_WRITE or RegFlags);
  try
    Reg.RootKey := Root;
    // Open the source key to read the value.
    if Reg.OpenKeyReadOnly(SourceKey) then
    begin
      if Reg.ValueExists(AppName) then
      begin
        AppCmd := Reg.ReadString(AppName);
        Reg.CloseKey;
        // Delete the value from the source key.
        if Reg.OpenKey(SourceKey, False) then
        begin
          try
            Reg.DeleteValue(AppName);
          except
            on E: Exception do
            begin
              LogMemo.Lines.Add(Format('Error deleting value for %s: %s', [AppName, E.Message]));
              Exit;
            end;
          end;
          Reg.CloseKey;
        end;
        // Write the value to the destination key.
        if Reg.OpenKey(DestKey, True) then
        begin
          try
            Reg.WriteString(AppName, AppCmd);
          except
            on E: Exception do
            begin
              LogMemo.Lines.Add(Format('Error setting data for %s: %s', [AppName, E.Message]));
              Exit;
            end;
          end;
          Reg.CloseKey;
        end;
        if Enable then
          LogMemo.Lines.Add(Format('Enabled startup app "%s" in %s.', [AppName, Scope]))
        else
          LogMemo.Lines.Add(Format('Disabled startup app "%s" in %s.', [AppName, Scope]));
      end
      else
        LogMemo.Lines.Add(Format('App "%s" not found in %s.', [AppName, SourceKey]));
    end
    else
      LogMemo.Lines.Add(Format('Unable to open registry key: %s.', [SourceKey]));
  finally
    Reg.Free;
  end;
end;


 {*
  Lists startup applications from both HKCU and HKLM.
  Populates a given ListView with the following columns:
    - App Name (stored in the item’s Caption)
    - Command (the registry value)
    - Status ("Enabled" or "Disabled")
    - Scope ("HKCU" or "HKLM")
*}
procedure ListStartupAppsExtended(ListView: TListView; LogMemo: TMemo);
var
  Reg: TRegistry;
  Names: TStringList;
  i: Integer;
  AppName, AppCmd, Status, Scope: string;
  ListItem: TListItem;
begin
  ListView.Items.BeginUpdate;
  try
    ListView.Clear;
    // Set up columns (if not already present)
    if ListView.Columns.Count = 0 then
    begin
      with ListView.Columns.Add do begin Caption := 'App Name'; Width := 200; end;
      with ListView.Columns.Add do begin Caption := 'Command'; Width := 400; end;
      with ListView.Columns.Add do begin Caption := 'Status'; Width := 100; end;
      with ListView.Columns.Add do begin Caption := 'Scope'; Width := 100; end;
    end;

    Names := TStringList.Create;
    Reg := TRegistry.Create(KEY_READ);
    try
      // --- HKCU: Enabled apps ---
      Reg.RootKey := HKEY_CURRENT_USER;
      if Reg.OpenKeyReadOnly(StartupKey_CU) then
      begin
        Reg.GetValueNames(Names);
        for i := 0 to Names.Count - 1 do
        begin
          AppName := Names[i];
          AppCmd := Reg.ReadString(AppName);
          Status := 'Enabled';
          Scope := 'HKCU';
          ListItem := ListView.Items.Add;
          ListItem.Caption := AppName;
          ListItem.SubItems.Add(AppCmd);
          ListItem.SubItems.Add(Status);
          ListItem.SubItems.Add(Scope);
          ListItem.Checked := True;
        end;
        Reg.CloseKey;
      end;

      Names.Clear;
      // --- HKCU: Disabled apps ---
      if Reg.OpenKeyReadOnly(StartupDisabledKey_CU) then
      begin
        Reg.GetValueNames(Names);
        for i := 0 to Names.Count - 1 do
        begin
          AppName := Names[i];
          AppCmd := Reg.ReadString(AppName);
          Status := 'Disabled';
          Scope := 'HKCU';
          ListItem := ListView.Items.Add;
          ListItem.Caption := AppName;
          ListItem.SubItems.Add(AppCmd);
          ListItem.SubItems.Add(Status);
          ListItem.SubItems.Add(Scope);
          ListItem.Checked := False;
        end;
        Reg.CloseKey;
      end;

      Names.Clear;
      // --- HKLM: Enabled apps (requires elevated privileges) ---
      Reg.RootKey := HKEY_LOCAL_MACHINE;
      if Reg.OpenKeyReadOnly(StartupKey_LM) then
      begin
        Reg.GetValueNames(Names);
        for i := 0 to Names.Count - 1 do
        begin
          AppName := Names[i];
          AppCmd := Reg.ReadString(AppName);
          Status := 'Enabled';
          Scope := 'HKLM';
          ListItem := ListView.Items.Add;
          ListItem.Caption := AppName;
          ListItem.SubItems.Add(AppCmd);
          ListItem.SubItems.Add(Status);
          ListItem.SubItems.Add(Scope);
          ListItem.Checked := True;
        end;
        Reg.CloseKey;
      end;

      Names.Clear;
      // --- HKLM: Disabled apps ---
      if Reg.OpenKeyReadOnly(StartupDisabledKey_LM) then
      begin
        Reg.GetValueNames(Names);
        for i := 0 to Names.Count - 1 do
        begin
          AppName := Names[i];
          AppCmd := Reg.ReadString(AppName);
          Status := 'Disabled';
          Scope := 'HKLM';
          ListItem := ListView.Items.Add;
          ListItem.Caption := AppName;
          ListItem.SubItems.Add(AppCmd);
          ListItem.SubItems.Add(Status);
          ListItem.SubItems.Add(Scope);
          ListItem.Checked := False;
        end;
        Reg.CloseKey;
      end;
    except
      on E: Exception do
        LogMemo.Lines.Add('Error enumerating startup apps: ' + E.Message);
    end;
    Reg.Free;
    Names.Free;
  finally
    ListView.Items.EndUpdate;
  end;
end;


  {*
  Returns True if the current process is running with elevated privileges.
*}


{* Helper to enumerate startup folder items *}
procedure EnumerateStartupFolder(const FolderPath, DisplayName: string;
  ListView: TListView; LogMemo: TMemo);
var
  Files: TArray<string>;
  FileName: string;
  ListItem: TListItem;
begin
  if not TDirectory.Exists(FolderPath) then
  begin
    LogMemo.Lines.Add(Format('Startup folder not found: %s (%s)', [FolderPath, DisplayName]));
    Exit;
  end;
  Files := TDirectory.GetFiles(FolderPath, '*.lnk');
  for FileName in Files do
  begin
    ListItem := ListView.Items.Add;
    ListItem.Caption := ExtractFileName(FileName);
    // Assuming the command is simply the full path to the shortcut.
    ListItem.SubItems.Add(FileName);
    ListItem.SubItems.Add('Enabled'); // assume enabled if present
    ListItem.SubItems.Add(DisplayName);
    ListItem.SubItems.Add('Folder');
  end;
  LogMemo.Lines.Add(Format('Enumerated %d items from %s folder.', [Length(Files), DisplayName]));
end;



procedure RemoveDuplicateStartupEntries(ListView: TListView);
var
  i, j: Integer;
begin
  // Loop backward so that deletion doesn't affect our iteration.
  for i := ListView.Items.Count - 1 downto 0 do
  begin
    for j := 0 to i - 1 do
    begin
      // Compare the App Name (stored in Caption) and the Command (assumed to be in SubItems[0]).
      if SameText(ListView.Items[i].Caption, ListView.Items[j].Caption) and
         (ListView.Items[i].SubItems.Count > 0) and
         (ListView.Items[j].SubItems.Count > 0) and
         SameText(ListView.Items[i].SubItems[0], ListView.Items[j].SubItems[0]) then
      begin
        ListView.Items[i].Delete;
        Break;
      end;
    end;
  end;
end;

procedure ListAllStartupApps(ListView: TListView; LogMemo: TMemo);
type
  TMyKeyInfo = record
    Root: HKEY;
    KeyPath: string;
    DisplayName: string;
  end;
const
  MyKeyInfos: array[0..7] of TMyKeyInfo = (
    (Root: HKEY_CURRENT_USER; KeyPath: 'Software\Microsoft\Windows\CurrentVersion\Run';          DisplayName: 'HKCU Run'),
    (Root: HKEY_CURRENT_USER; KeyPath: 'Software\Microsoft\Windows\CurrentVersion\RunOnce';      DisplayName: 'HKCU RunOnce'),
    (Root: HKEY_LOCAL_MACHINE;  KeyPath: 'Software\Microsoft\Windows\CurrentVersion\Run';          DisplayName: 'HKLM Run'),
    (Root: HKEY_LOCAL_MACHINE;  KeyPath: 'Software\Microsoft\Windows\CurrentVersion\RunOnce';      DisplayName: 'HKLM RunOnce'),
    (Root: HKEY_CURRENT_USER;   KeyPath: 'Software\Microsoft\Windows\CurrentVersion\RunDisabled';    DisplayName: 'HKCU RunDisabled'),
    (Root: HKEY_LOCAL_MACHINE;  KeyPath: 'Software\Microsoft\Windows\CurrentVersion\RunDisabled';    DisplayName: 'HKLM RunDisabled'),
    // Extra entry for Computer\HKCU Run:
    (Root: HKEY_CURRENT_USER;   KeyPath: 'Software\Microsoft\Windows\CurrentVersion\Run';          DisplayName: 'Computer\HKCU Run'),
    // Extra entry for Computer\HKLM Run:
    (Root: HKEY_LOCAL_MACHINE;  KeyPath: 'Software\Microsoft\Windows\CurrentVersion\Run';          DisplayName: 'Computer\HKLM Run')
  );
var
  k: Integer;
  GlobalKeyInfo: TStartupKeyInfo; // Global type expected by EnumerateStartupKey
  StartupFolder, CommonStartupFolder: string;
begin
  ListView.Items.BeginUpdate;
  try
    ListView.Clear;
    // Setup columns if not already set
    if ListView.Columns.Count = 0 then
    begin
      with ListView.Columns.Add do
      begin
        Caption := 'App Name';
        Width := 200;
      end;
      with ListView.Columns.Add do
      begin
        Caption := 'Command';
        Width := 400;
      end;
      with ListView.Columns.Add do
      begin
        Caption := 'Status';
        Width := 100;
      end;
      with ListView.Columns.Add do
      begin
        Caption := 'Source';
        Width := 150;
      end;
      with ListView.Columns.Add do
      begin
        Caption := 'View';
        Width := 100;
      end;
    end;

    // Enumerate each registry key from our array for both 64-bit and 32-bit views.
    for k := Low(MyKeyInfos) to High(MyKeyInfos) do
    begin
      GlobalKeyInfo.Root := MyKeyInfos[k].Root;
      GlobalKeyInfo.KeyPath := MyKeyInfos[k].KeyPath;

      LogMemo.Lines.Add(Format('Enumerating key: %s (64-bit view)', [MyKeyInfos[k].DisplayName]));
      EnumerateStartupKey(GlobalKeyInfo, KEY_WOW64_64KEY, ListView, LogMemo);

      LogMemo.Lines.Add(Format('Enumerating key: %s (32-bit view)', [MyKeyInfos[k].DisplayName]));
      EnumerateStartupKey(GlobalKeyInfo, KEY_WOW64_32KEY, ListView, LogMemo);
      UpdateCheckboxesFromStatus(form3.lvStartUp);
    end;
  finally
    ListView.Items.EndUpdate;
  end;

  // Remove duplicate entries (from enumerating both registry views)
  RemoveDuplicateStartupEntries(ListView);

  // Now enumerate Startup folder items.
  // For current user:
  StartupFolder := IncludeTrailingPathDelimiter(GetEnvironmentVariable('APPDATA')) +
                   'Microsoft\Windows\Start Menu\Programs\Startup';
  LogMemo.Lines.Add('Enumerating User Startup Folder: ' + StartupFolder);
  EnumerateStartupFolder(StartupFolder, 'User Startup Folder', ListView, LogMemo);

  // For all users:
  CommonStartupFolder := IncludeTrailingPathDelimiter(GetEnvironmentVariable('ALLUSERSPROFILE')) +
                         'Microsoft\Windows\Start Menu\Programs\Startup';
  LogMemo.Lines.Add('Enumerating Common Startup Folder: ' + CommonStartupFolder);
  EnumerateStartupFolder(CommonStartupFolder, 'Common Startup Folder', ListView, LogMemo);

end;

procedure ListStartupApps(ListView: TListView; LogMemo: TMemo);
var
  Reg: TRegistry;
  Names: TStringList;
  i: Integer;
  AppName, AppCmd: string;
  ListItem: TListItem;
begin
  ListView.Items.BeginUpdate;
  try
    ListView.Clear;
    // Set up columns if needed
    if ListView.Columns.Count = 0 then
    begin
      with ListView.Columns.Add do
      begin
        Caption := 'App Name';
        Width := 200;
      end;
      with ListView.Columns.Add do
      begin
        Caption := 'Command';
        Width := 400;
      end;
      with ListView.Columns.Add do
      begin
        Caption := 'Status';
        Width := 100;
      end;
    end;

    Names := TStringList.Create;
    Reg := TRegistry.Create(KEY_READ);
    try
      // List enabled apps from HKCU\Run
      Reg.RootKey := HKEY_CURRENT_USER;
      if Reg.OpenKeyReadOnly(StartupKey_CU) then
      begin
        Reg.GetValueNames(Names);
        for i := 0 to Names.Count - 1 do
        begin
          AppName := Names[i];
          AppCmd := Reg.ReadString(AppName);
          ListItem := ListView.Items.Add;
          ListItem.Caption := AppName;
          ListItem.SubItems.Add(AppCmd);
          ListItem.SubItems.Add('Enabled');
          // Mark enabled apps with a checked state.
          ListItem.Checked := True;
        end;
        Reg.CloseKey;
      end;

      // List disabled apps from HKCU\RunDisabled
      Names.Clear;
      if Reg.OpenKeyReadOnly(StartupDisabledKey_CU) then
      begin
        Reg.GetValueNames(Names);
        for i := 0 to Names.Count - 1 do
        begin
          AppName := Names[i];
          AppCmd := Reg.ReadString(AppName);
          ListItem := ListView.Items.Add;
          ListItem.Caption := AppName;
          ListItem.SubItems.Add(AppCmd);
          ListItem.SubItems.Add('Disabled');
          // Mark disabled apps as unchecked.
          ListItem.Checked := False;
        end;
        Reg.CloseKey;
      end;
    except
      on E: Exception do
        LogMemo.Lines.Add('Error enumerating startup apps: ' + E.Message);
    end;
    Reg.Free;
    Names.Free;
  finally
    ListView.Items.EndUpdate;
  end;
end;


{*
  Toggles the startup status of a given application (by name).
  If Enable is False, the app is moved from HKCU\Run to HKCU\RunDisabled.
  If Enable is True, it is moved back.
*}
procedure ToggleStartupApp(const AppName: string; Enable: Boolean; LogMemo: TMemo);
var
  Reg: TRegistry;
  AppCmd: string;
begin
  Reg := TRegistry.Create(KEY_READ or KEY_WRITE);
  try
    Reg.RootKey := HKEY_CURRENT_USER;
    if Enable then
    begin
      // If enabling, check if it exists in the disabled key.
      if Reg.OpenKeyReadOnly(StartupDisabledKey_CU) then
      begin
        if Reg.ValueExists(AppName) then
        begin
          AppCmd := Reg.ReadString(AppName);
          Reg.CloseKey;
          // Delete from RunDisabled
          if Reg.OpenKey(StartupDisabledKey_CU, False) then
          begin
            Reg.DeleteValue(AppName);
            Reg.CloseKey;
          end;
          // Write it to Run key.
          if Reg.OpenKey(StartupKey_CU, True) then
          begin
            Reg.WriteString(AppName, AppCmd);
            Reg.CloseKey;
          end;
          LogMemo.Lines.Add(Format('Enabled startup app: %s', [AppName]));
        end;
      end;
    end
    else
    begin
      // If disabling, check if it exists in the enabled key.
      if Reg.OpenKeyReadOnly(StartupKey_CU) then
      begin
        if Reg.ValueExists(AppName) then
        begin
          AppCmd := Reg.ReadString(AppName);
          Reg.CloseKey;
          // Delete from Run key.
          if Reg.OpenKey(StartupKey_CU, False) then
          begin
            Reg.DeleteValue(AppName);
            Reg.CloseKey;
          end;
          // Write it to the RunDisabled key.
          if Reg.OpenKey(StartupDisabledKey_CU, True) then
          begin
            Reg.WriteString(AppName, AppCmd);
            Reg.CloseKey;
          end;
          LogMemo.Lines.Add(Format('Disabled startup app: %s', [AppName]));
        end;
      end;
    end;
  except
    on E: Exception do
      LogMemo.Lines.Add('Error toggling startup app: ' + E.Message);
  end;
  Reg.Free;
end;

procedure ApplyStartupCheckboxes(ListView: TListView; LogMemo: TMemo);
var
  i: Integer;
  AppName: string;
  EnableStartup: Boolean;
begin
  // Loop through each item in the ListView.
  for i := 0 to ListView.Items.Count - 1 do
  begin
    // Assume the startup application's name is stored in the item caption.
    AppName := ListView.Items[i].Caption;

    // If the checkbox is checked, we want the startup app enabled.
    EnableStartup := ListView.Items[i].Checked;

    // Call the routine to toggle the startup state.
    // This procedure should move the app between the enabled and disabled registry keys.
    ToggleStartupApp(AppName, EnableStartup, LogMemo);

    // Update the "Status" column.
    // Assuming the "Status" is stored as the second subitem (index 1).
    if ListView.Items[i].SubItems.Count >= 2 then
    begin
      if EnableStartup then
        ListView.Items[i].SubItems[1] := 'Enabled'
      else
        ListView.Items[i].SubItems[1] := 'Disabled';
    end;

    // Log the new state.
    if EnableStartup then
      LogMemo.Lines.Add(Format('Enabled startup app: %s', [AppName]))
    else
      LogMemo.Lines.Add(Format('Disabled startup app: %s', [AppName]));
  end;
end;



  procedure TForm3.InstallSelectedDriverUpdates;
var
  UpdateSession, UpdateInstaller, UpdateColl: OleVariant;
  i, SelectedCount: Integer;
  LItem: TListItem;
  InstallationResult: OleVariant;
begin
  // Create a new update collection object.
  UpdateColl := CreateOleObject('Microsoft.Update.UpdateColl');

  SelectedCount := 0;
  // Iterate over the ListView2 items.
  for i := 0 to ListView2.Items.Count - 1 do
  begin
    LItem := ListView2.Items[i];
    if LItem.Checked then
    begin
      // Add the update from our global FUpdateList.
      if (i < FUpdateList.Count) then
      begin
        UpdateColl.Add(FUpdateList[i]);
        Inc(SelectedCount);
      end;
    end;
  end;

  if SelectedCount = 0 then
  begin
    ShowMessage('No updates selected.');
    Exit;
  end;

  try
    CoInitialize(nil);
    // Create an update session and installer.
    UpdateSession := CreateOleObject('Microsoft.Update.Session');
    UpdateInstaller := UpdateSession.CreateUpdateInstaller;

    // Set the installer’s Updates property to our collection.
    UpdateInstaller.Updates := UpdateColl;

    // Optionally, you can show a progress UI here.
    InstallationResult := UpdateInstaller.Install;

    // Check the result.
    if InstallationResult.ResultCode = 2 then
      ShowMessage('Driver updates installed successfully.')
    else
      ShowMessage('Some driver updates failed to install. Result code: ' +
        IntToStr(InstallationResult.ResultCode));
  except
    on E: Exception do
      ShowMessage('Error installing driver updates: ' + E.Message);
  end;
  CoUninitialize;
end;


procedure TForm3.InstallDriverUpdates;
var
  UpdateSession: OLEVariant;
  UpdateSearcher: OLEVariant;
  SearchResult: OLEVariant;
  UpdateInstaller: OLEVariant;
  InstallationResult: OLEVariant;
  i: Integer;
  SelectedUpdates: TList<OLEVariant>;
  Update: OLEVariant;
begin
  // Make sure the application runs with administrative privileges.
  CoInitialize(nil);
  try
    UpdateSession := CreateOleObject('Microsoft.Update.Session');
    UpdateSearcher := UpdateSession.CreateUpdateSearcher;
    SearchResult := UpdateSearcher.Search('Type="Driver"');
    if SearchResult.Updates.Count = 0 then
    begin
      ShowMessage('No driver updates found.');
      Exit;
    end;

    // Here you could loop through SearchResult.Updates and display them in a UI (like a checklist)
    // so the user can choose which ones to install. For simplicity, this example installs all.

    UpdateInstaller := UpdateSession.CreateUpdateInstaller;
    UpdateInstaller.Updates := SearchResult.Updates;
    InstallationResult := UpdateInstaller.Install;
    if InstallationResult.ResultCode = 2 then
      ShowMessage('Driver updates installed successfully.')
    else
      ShowMessage('Some driver updates failed to install.');
  except
    on E: Exception do
      ShowMessage('Error installing driver updates: ' + E.Message);
  end;
  CoUninitialize;
end;


//{*******************************************************************************}
//{ Method 2: WMI (Win32_PnPSignedDriver) }
//{*******************************************************************************}
//procedure CheckForDriverUpdates_WMI(ListView: TListView; LogMemo: TMemo);
//var
//  Locator: OLEVariant;
//  Services: OLEVariant;
//  Drivers: OLEVariant;
//  Driver: OLEVariant;
//  Enum: IEnumVariant;
//  Value: LongWord;
//  Fetched: OLEVariant;
//  RawDate: string;
//  YearNum, MonthNum, DayNum: Word;
//  InstallDate: TDateTime;
//  Today: TDateTime;
//  DaysOld: Double;
//  DeviceName: string;
//  SeenList: TStringList;
//  I: Integer;
//begin
//  Form3.ListView1.Visible := False;
//  Form3.ListView2.Visible := True;
//  form3.ListView2.Align:=alClient;
//  // Ensure ListView is in report view
//  ListView.ViewStyle := vsReport;
//
//  // Clear any existing columns if they exist
//  ListView.Columns.Clear;
//
//  // Add columns for report view
//  with ListView.Columns.Add do
//  begin
//    Caption := 'Device Name';
//    Width := 200;
//  end;
//  with ListView.Columns.Add do
//  begin
//    Caption := 'Driver Version';
//    Width := 100;
//  end;
//  with ListView.Columns.Add do
//  begin
//    Caption := 'Driver Date';
//    Width := 100;
//  end;
//  with ListView.Columns.Add do
//  begin
//    Caption := 'Age';
//    Width := 100;
//  end;
//
//  ListView.Items.BeginUpdate;
//  try
//    ListView.Items.Clear;
//    SeenList := TStringList.Create;
//    try
//      CoInitialize(nil);
//      try
//        Locator  := CreateOleObject('WbemScripting.SWbemLocator');
//        Services := Locator.ConnectServer('.', 'root\CIMV2');
//        // Query signed drivers
//        Drivers := Services.ExecQuery('SELECT DeviceName, DriverVersion, DriverDate FROM Win32_PnPSignedDriver');
//        Enum := IUnknown(Drivers._NewEnum) as IEnumVariant;
//        while Enum.Next(1, Fetched, Value) = 0 do
//        begin
//          Driver := Fetched;
//          DeviceName := VarToStr(Driver.DeviceName);
//          // Skip if we've already added this device
//          if SeenList.IndexOf(DeviceName) <> -1 then
//            Continue;
//          SeenList.Add(DeviceName);
//
//          // Extract the first 8 characters (YYYYMMDD)
//          RawDate := VarToStr(Driver.DriverDate);
//          if Length(RawDate) >= 8 then
//          begin
//            try
//              YearNum  := StrToInt(Copy(RawDate, 1, 4));
//              MonthNum := StrToInt(Copy(RawDate, 5, 2));
//              DayNum   := StrToInt(Copy(RawDate, 7, 2));
//              InstallDate := EncodeDate(YearNum, MonthNum, DayNum);
//            except
//              InstallDate := 0;
//            end;
//          end
//          else
//            InstallDate := 0;
//
//          Today   := Now;
//          DaysOld := Today - InstallDate;
//          // If driver older than 180 days, flag as needing update (example criteria)
//          if (InstallDate > 0) and (DaysOld > 180) then
//          begin
//            with ListView.Items.Add do
//            begin
//              Caption := DeviceName;
//              SubItems.Add(VarToStr(Driver.DriverVersion));
//              SubItems.Add(FormatDateTime('yyyy-mm-dd', InstallDate));
//              SubItems.Add(Format('~%.0f days old', [DaysOld]));
//            end;
//          end;
//        end;
//
//        // Auto-size columns based on content
//        for I := 0 to ListView.Columns.Count - 1 do
//          ListView.Columns[I].Width := -1; // -1 means auto-size to content
//          // Alternatively: ListView.Columns[I].AutoSize := True;
//
//        LogMemo.Lines.Add(Format('WMI scan completed; found %d potential outdated driver(s).', [ListView.Items.Count]));
//      except
//        on E: Exception do
//          LogMemo.Lines.Add('WMI Error: ' + E.Message);
//      end;
//      CoUninitialize;
//    finally
//      SeenList.Free;
//    end;
//  finally
//    ListView.Items.EndUpdate;
//  end;
//end;


procedure CheckForDriverUpdates_WMI(ListView: TListView; LogMemo: TMemo);
var
  Locator: OLEVariant;
  Services: OLEVariant;
  Drivers: OLEVariant;
  Driver: OLEVariant;
  Enum: IEnumVariant;
  Value: LongWord;
  Fetched: OLEVariant;
  RawDate: string;
  YearNum, MonthNum, DayNum: Word;
  InstallDate: TDateTime;
  Today: TDateTime;
  DaysOld: Double;
  DeviceName: string;
  SeenList: TStringList;
  I: Integer;

  // Local function for age formatting
  function FormatAge(DaysOld: Double): string;
  var
    TotalDays: Integer;
    Years, Months, Days: Integer;
  begin
    TotalDays := Trunc(DaysOld);
    if TotalDays < 0 then TotalDays := 0;

    Years := TotalDays div 365;
    Months := (TotalDays mod 365) div 30;
    Days := (TotalDays mod 365) mod 30;

    Result := '';
    if Years > 0 then
      Result := Result + IntToStr(Years) + 'y ';
    if Months > 0 then
      Result := Result + IntToStr(Months) + 'm ';
    Result := Result + IntToStr(Days) + 'd';
  end;

begin


  // Configure ListView for report view
  ListView.ViewStyle := vsReport;
  ListView.Columns.Clear;

  // Add columns
  with ListView.Columns.Add do
  begin
    Caption := 'Device Name';
    Width := 250;
  end;
  with ListView.Columns.Add do
  begin
    Caption := 'Driver Version';
    Width := 120;
  end;
  with ListView.Columns.Add do
  begin
    Caption := 'Driver Date';
    Width := 100;
  end;
  with ListView.Columns.Add do
  begin
    Caption := 'Age';
    Width := 80;
  end;

  ListView.Items.BeginUpdate;
  try
    ListView.Items.Clear;
    SeenList := TStringList.Create;
    SeenList.Sorted := True;  // Faster lookups
    SeenList.Duplicates := dupIgnore;
    try
      CoInitialize(nil);
      try
        Locator := CreateOleObject('WbemScripting.SWbemLocator');
        Services := Locator.ConnectServer('.', 'root\CIMV2');
        Drivers := Services.ExecQuery('SELECT DeviceName, DriverVersion, DriverDate FROM Win32_PnPSignedDriver');
        Enum := IUnknown(Drivers._NewEnum) as IEnumVariant;

        while Enum.Next(1, Fetched, Value) = 0 do
        begin
          Driver := Fetched;
          DeviceName := VarToStr(Driver.DeviceName);

          // Skip duplicates
          if SeenList.IndexOf(DeviceName) >= 0 then
            Continue;
          SeenList.Add(DeviceName);

          // Parse driver date (YYYYMMDD format)
          RawDate := VarToStr(Driver.DriverDate);
          if Length(RawDate) >= 8 then
          begin
            try
              YearNum := StrToIntDef(Copy(RawDate, 1, 4), 0);
              MonthNum := StrToIntDef(Copy(RawDate, 5, 2), 0);
              DayNum := StrToIntDef(Copy(RawDate, 7, 2), 0);

              if (YearNum > 0) and (MonthNum in [1..12]) and (DayNum in [1..31]) then
                InstallDate := EncodeDate(YearNum, MonthNum, DayNum)
              else
                InstallDate := 0;
            except
              InstallDate := 0;
            end;
          end
          else
            InstallDate := 0;

          Today := Now;
          DaysOld := Today - InstallDate;

          // Only show drivers older than 180 days
          if (InstallDate > 0) and (DaysOld > 180) then
          begin
            with ListView.Items.Add do
            begin
              Caption := DeviceName;
              SubItems.Add(VarToStr(Driver.DriverVersion));
              SubItems.Add(FormatDateTime('yyyy-mm-dd', InstallDate));
              SubItems.Add(FormatAge(DaysOld));  // Formatted age
            end;
          end;
        end;

        // Auto-size columns to fit content
        for I := 0 to ListView.Columns.Count - 1 do
          ListView.Columns[I].Width := -2;  // Auto-size to header and content

        LogMemo.Lines.Add(Format('WMI scan completed. Found %d potentially outdated drivers.', [ListView.Items.Count]));
      except
        on E: Exception do
          LogMemo.Lines.Add('WMI Error: ' + E.Message);
      end;
      CoUninitialize;
    finally
      SeenList.Free;
    end;
  finally
    ListView.Items.EndUpdate;
  end;
end;


procedure TForm3.CheckForDriverUpdates;
var
  UpdateSearcher: OLEVariant;
  SearchResult: OLEVariant;
  Update: OLEVariant;
  i: Integer;
begin
  LogMemo.Lines.Add('Searching for driver updates via Windows Update...');
  CoInitialize(nil);
  try
    UpdateSearcher := CreateOleObject('Microsoft.Update.Searcher');
    try
      SearchResult := UpdateSearcher.Search('Type="Driver"');
      if SearchResult.Updates.Count > 0 then
      begin
        for i := 0 to SearchResult.Updates.Count - 1 do
        begin
          Update := SearchResult.Updates.Item[i];
          LogMemo.Lines.Add(Format('Update %d: %s', [i + 1, Update.Title]));
        end;
      end
      else
        LogMemo.Lines.Add('No driver updates found.');
    except
      on E: EOleSysError do
        // Compare the error code as Cardinal so that 0x80240032 matches properly.
        if Cardinal(E.ErrorCode) = $80240032 then
          LogMemo.Lines.Add('No driver updates found.')
        else
          LogMemo.Lines.Add('Error searching for driver updates: ' + E.Message);
      on E: Exception do
        LogMemo.Lines.Add('Error searching for driver updates: ' + E.Message);
    end;
  finally
    CoUninitialize;
  end;
end;






// -----------------------------------------------------------------------------
// **New** Wide (Unicode) Declarations (added so your "W" calls work)
// -----------------------------------------------------------------------------
// 1) A small helper to do case-insensitive substring checks.
function ContainsText(const AText, ASubText: string): Boolean;
begin
  Result := Pos(LowerCase(ASubText), LowerCase(AText)) > 0;
end;

procedure TForm3.PopulateDriverUpdates;
var
  UpdateSession, UpdateSearcher, SearchResult, Update: OleVariant;
  i: Integer;
  LItem: TListItem;
begin
  // Hide ListView2 initially.
  ListView2.Visible := False;
  LogMemo.Lines.Add('Searching for driver updates via Windows Update...');
  CoInitialize(nil);
  try
    UpdateSession := CreateOleObject('Microsoft.Update.Session');
    UpdateSearcher := UpdateSession.CreateUpdateSearcher;

    // Search for driver updates.
    SearchResult := UpdateSearcher.Search('Type="Driver"');

    ListView2.Items.BeginUpdate;
    try
      ListView2.Items.Clear;
      FUpdateList.Clear;

      if SearchResult.Updates.Count > 0 then
      begin
        // If updates are found, show the list view.
        ListView2.Visible := True;
        for i := 0 to SearchResult.Updates.Count - 1 do
        begin
          Update := SearchResult.Updates.Item[i];
          FUpdateList.Add(Update);

          LItem := ListView2.Items.Add;
          LItem.Caption := VarToStr(Update.Title);
          if VarIsEmpty(Update.Description) then
            LItem.SubItems.Add('')
          else
            LItem.SubItems.Add(VarToStr(Update.Description));
          LItem.Checked := False;
        end;
      end
      else
      begin
        LogMemo.Lines.Add('No driver updates found.');
        ListView2.Visible := False;
      end;
    finally
      ListView2.Items.EndUpdate;
    end;
  except
    on E: EOleSysError do
      if Cardinal(E.ErrorCode) = $80240032 then
      begin
        LogMemo.Lines.Add('No driver updates found.');
        ListView2.Visible := False;
      end
      else
        LogMemo.Lines.Add('Error populating driver updates: ' + E.Message);
    on E: Exception do
      LogMemo.Lines.Add('Error populating driver updates: ' + E.Message);
  end;
  CoUninitialize;
end;

//  function TForm3.GetMotherboardInfo: string;
//var
//  WbemLocator, WMIService, MBList, MB: OleVariant;
//  Enum: IEnumVariant;
//  Dummy: Cardinal;
//  MBManufacturer, MBProduct, MBVersion: string;
//begin
//  Result := 'Motherboard info not found';
//  form3.LogMemo.Lines.Add('Querying motherboard information...');
//  CoInitialize(nil);
//  try
//    // Create the WMI locator and connect to the CIMV2 namespace.
//    WbemLocator := CreateOleObject('WbemScripting.SWbemLocator');
//    WMIService := WbemLocator.ConnectServer('.', 'root\CIMV2');
//    // Execute a query on the Win32_BaseBoard class.
//    MBList := WMIService.ExecQuery('SELECT Manufacturer, Product, Version FROM Win32_BaseBoard');
//    Enum := IUnknown(MBList._NewEnum) as IEnumVariant;
//    // Retrieve the first element.
//    if Enum.Next(1, MB, Dummy) = 0 then
//    begin
//      MBManufacturer := VarToStr(MB.Manufacturer);
//      MBProduct := VarToStr(MB.Product);
//      MBVersion := VarToStr(MB.Version);
//      form3.LogMemo.Lines.Add('Motherboard Manufacturer: ' + MBManufacturer);
//      form3.LogMemo.Lines.Add('Motherboard Product: ' + MBProduct);
//      form3.LogMemo.Lines.Add('Motherboard Version: ' + MBVersion);
//      Result := Format('Motherboard: %s %s (Version: %s)', [MBManufacturer, MBProduct, MBVersion]);
//    end
//    else
//      form3.LogMemo.Lines.Add('No motherboard information found.');
//  finally
//    CoUninitialize;
//  end;
//end;
//

//procedure TForm3.GetMotherboardInfo;
//var
//  WbemLocator, WMIService, MBList, MB: OLEVariant;
//  Enum: IEnumVariant;
//  Dummy: Cardinal;
//  MBManufacturer, MBProduct, MBVersion: string;
//begin
//  LogMemo.Lines.Add('Querying motherboard information...');
//  CoInitialize(nil);
//  try
//    // Create the WMI locator and connect to the CIMV2 namespace
//    WbemLocator := CreateOleObject('WbemScripting.SWbemLocator');
//    WMIService := WbemLocator.ConnectServer('.', 'root\CIMV2');
//    // Execute a query on the Win32_BaseBoard class
//    MBList := WMIService.ExecQuery('SELECT Manufacturer, Product, Version FROM Win32_BaseBoard');
//    Enum := IUnknown(MBList._NewEnum) as IEnumVariant;
//    // Use a dummy variable instead of nil for the fetched count
//    if Enum.Next(1, MB, Dummy) = 0 then
//    begin
//      MBManufacturer := VarToStr(MB.Manufacturer);
//      MBProduct := VarToStr(MB.Product);
//      MBVersion := VarToStr(MB.Version);
//      LogMemo.Lines.Add('Motherboard Manufacturer: ' + MBManufacturer);
//      LogMemo.Lines.Add('Motherboard Product: ' + MBProduct);
//      LogMemo.Lines.Add('Motherboard Version: ' + MBVersion);
//      ShowMessage(Format('Motherboard: %s %s (Version: %s)', [MBManufacturer, MBProduct, MBVersion]));
//    end
//    else
//      LogMemo.Lines.Add('No motherboard information found.');
//  finally
//    CoUninitialize;
//  end;
//end;
//

function LoadVendorMapping(const FileName: string): TJSONObject;
var
  JSONString: TStringList;
  JSONValue: TJSONValue;
  JSONArray: TJSONArray;
  MappingObj: TJSONObject;
  i: Integer;
  VendorObj: TJSONObject;
  VendorID, VendorName: string;
begin
  Result := nil;

  JSONString := TStringList.Create;
  try
    JSONString.LoadFromFile(FileName);

    // Parse the entire JSON text into a TJSONValue
    JSONValue := TJSONObject.ParseJSONValue(JSONString.Text);
    try
      if not Assigned(JSONValue) or not(JSONValue is TJSONArray) then
        Exit(nil);

      JSONArray := JSONValue as TJSONArray;

      // Build a TJSONObject like:
      // { "8086": "Intel Corporation", "1002": "AMD/ATI", ... }
      MappingObj := TJSONObject.Create;

      for i := 0 to JSONArray.Count - 1 do
      begin
        if not(JSONArray.Items[i] is TJSONObject) then
          Continue;

        VendorObj := TJSONObject(JSONArray.Items[i]);

        // Extract "Vendor ID" and "Vendor Name"
        VendorID := VendorObj.GetValue<string>('Vendor ID', '');
        VendorName := VendorObj.GetValue<string>('Vendor Name', '');

        if (VendorID <> '') and (VendorName <> '') then
          MappingObj.AddPair(VendorID, VendorName);
      end;

      Result := MappingObj;
    finally
      JSONValue.Free;
    end;
  finally
    JSONString.Free;
  end;
end;

function SetupDiGetClassDevsW(ClassGuid: PGUID; Enumerator: PChar;
  hwndParent: HWND; Flags: DWORD): HDEVINFO; stdcall;
  external 'SetupAPI.dll' name 'SetupDiGetClassDevsW';

function SetupDiGetDeviceRegistryPropertyW(DeviceInfoSet: HDEVINFO;
  DeviceInfoData: PSP_DEVINFO_DATA; Property_: DWORD;
  PropertyRegDataType: PDWORD; PropertyBuffer: PBYTE; PropertyBufferSize: DWORD;
  RequiredSize: PDWORD): BOOL; stdcall;
  external 'SetupAPI.dll' name 'SetupDiGetDeviceRegistryPropertyW';

function SetupDiGetDeviceInstanceIdW(DeviceInfoSet: HDEVINFO;
  DeviceInfoData: PSP_DEVINFO_DATA; DeviceInstanceId: PWideChar;
  DeviceInstanceIdSize: DWORD; RequiredSize: PDWORD): BOOL; stdcall;
  external 'SetupAPI.dll' name 'SetupDiGetDeviceInstanceIdW';
// -----------------------------------------------------------------------------

// -----------------------------------------------------------------------------
// Utility functions
// -----------------------------------------------------------------------------
procedure TForm3.LocateDriverOnOS(const DriverKey: string);
var
  Reg: TRegistry;
  DriverPath, DriverFileName: string;
begin
  try
    // Access the registry to find the driver file name
    Reg := TRegistry.Create(KEY_READ);
    try
      Reg.RootKey := HKEY_LOCAL_MACHINE;
      if Reg.OpenKeyReadOnly('\SYSTEM\CurrentControlSet\Services\' + DriverKey) then
      begin
        if Reg.ValueExists('ImagePath') then
        begin
          DriverFileName := Reg.ReadString('ImagePath');
          DriverPath := ExpandFileName(DriverFileName);
          if FileExists(DriverPath) then
          begin
            LogMemo.Lines.Add('Driver found at: ' + DriverPath);
            ShellExecute(Handle, 'open', PChar(DriverPath), nil, nil, SW_SHOWNORMAL);
            Exit;
          end;
        end;
      end;
    finally
      Reg.Free;
    end;

    // If not found, display an error
    LogMemo.Lines.Add('Driver not found for key: ' + DriverKey);
    ShowMessage('Driver not found for the system: ' + DriverKey);
  except
    on E: Exception do
      LogMemo.Lines.Add('Error locating driver: ' + E.Message);
  end;
end;






procedure TForm3.lvStartUpDblClick(Sender: TObject);
var
  LItem: TListItem;
  AppName, SourceStr, RootKeyStr, SubKeyPath: string;
  Root: HKEY;
  Reg: TRegistry;
  Confirm: Integer;
begin
  if not Assigned(lvStartUp.Selected) then
    Exit;

  LItem := lvStartUp.Selected;
  AppName := LItem.Caption;
  // Expecting Source column at index 3
  if LItem.SubItems.Count < 4 then
  begin
    ShowMessage('Source information is missing for the selected app.');
    Exit;
  end;
  SourceStr := LItem.SubItems[3];

  Confirm := MessageDlg(Format('Are you sure you want to remove "%s" from startup?', [AppName]),
    mtConfirmation, [mbYes, mbNo], 0);
  if Confirm <> mrYes then
    Exit;

  // Determine root and subkey based on the Source string.
  // For example, if SourceStr = 'HKCU\Run', then:
  //   RootKeyStr = 'HKCU' and SubKeyPath = 'Software\Microsoft\Windows\CurrentVersion\Run'
  // We'll assume that the Source strings match the ones used in your ListAllStartupApps procedure.
  if Pos('HKCU', UpperCase(SourceStr)) = 1 then
  begin
    Root := HKEY_CURRENT_USER;
    // Assuming the key path for HKCU entries is exactly StartupKey_CU or StartupDisabledKey_CU.
    // Here we extract the portion after 'HKCU\'.
    SubKeyPath := Copy(SourceStr, 6, MaxInt);
  end
  else if Pos('HKLM', UpperCase(SourceStr)) = 1 then
  begin
    Root := HKEY_LOCAL_MACHINE;
    SubKeyPath := Copy(SourceStr, 6, MaxInt);
  end
  else
  begin
    ShowMessage('Unknown registry scope for the selected app.');
    Exit;
  end;

  // Open the registry and delete the value.
  Reg := TRegistry.Create(KEY_WRITE or KEY_WOW64_64KEY);
  try
    Reg.RootKey := Root;
    if Reg.OpenKey(SubKeyPath, False) then
    begin
      if Reg.ValueExists(AppName) then
      begin
        try
          Reg.DeleteValue(AppName);
          LogMemo.Lines.Add(Format('Removed "%s" from %s', [AppName, SourceStr]));
        except
          on E: Exception do
            LogMemo.Lines.Add(Format('Error removing "%s": %s', [AppName, E.Message]));
        end;
      end
      else
        LogMemo.Lines.Add(Format('"%s" was not found in %s', [AppName, SourceStr]));
      Reg.CloseKey;
    end
    else
      LogMemo.Lines.Add(Format('Unable to open key: %s', [SourceStr]));
  finally
    Reg.Free;
  end;

  // Refresh the startup list.
  ListAllStartupApps(lvStartUp, LogMemo);
end;


procedure TForm3.lvStartUpItemChecked(Sender: TObject; Item: TListItem);
var
  AppName, AppCmd, SourceStr: string;
  IsEnabled: Boolean;
  UserScope: Boolean;
begin
  AppName := Item.Caption;
  if Item.SubItems.Count > 0 then
    AppCmd := Item.SubItems[0]
  else
    AppCmd := '';

  if Item.SubItems.Count >= 4 then
    SourceStr := Item.SubItems[3]
  else
    SourceStr := '';

  IsEnabled := Item.Checked;

  if Pos('HKLM', UpperCase(SourceStr)) > 0 then
    UserScope := False
  else
    UserScope := True;

  ToggleStartupAppExtended(AppName, IsEnabled, SourceStr, LogMemo);
  SetStartupApproved(AppName, IsEnabled, UserScope, LogMemo);

  if Item.SubItems.Count > 1 then
  begin
    if IsEnabled then
      Item.SubItems[1] := 'Enabled'
    else
      Item.SubItems[1] := 'Disabled';
  end;

  // Post the WM_SETTINGCHANGE message asynchronously to avoid UI lockup.
  PostMessage(HWND_BROADCAST, WM_SETTINGCHANGE, 0, 0);
end;


function GetVendorName(const VendorID: string;
  VendorMapping: TJSONObject): string;
begin
  if VendorMapping.Values[VendorID] <> nil then
    Result := VendorMapping.Values[VendorID].Value
  else
    Result := 'Unknown Vendor';
end;

// -----------------------------------------------------------------------------
// Procedure that uses Wide calls
// -----------------------------------------------------------------------------
function GetDeviceProperty(DeviceInfoSet: HDEVINFO;
  var DeviceInfoData: SP_DEVINFO_DATA; PropertyCode: DWORD): string;
const
  BUFFER_SIZE = 1024;
var
  Buffer: array [0 .. BUFFER_SIZE - 1] of WideChar;
  RequiredSize: DWORD;
begin
  Result := '';
  if SetupDiGetDeviceRegistryPropertyW(DeviceInfoSet, @DeviceInfoData,
    PropertyCode, nil, PBYTE(@Buffer), SizeOf(Buffer), @RequiredSize) then
    Result := WideCharToString(Buffer)
  else
    Result := 'N/A';
end;

function GetDeviceInstanceId(DeviceInfoSet: HDEVINFO;
  var DeviceInfoData: SP_DEVINFO_DATA): string;
const
  BUFFER_SIZE = 1024;
var
  Buffer: array [0 .. BUFFER_SIZE - 1] of WideChar;
  RequiredSize: DWORD;
begin
  Result := '';
  if SetupDiGetDeviceInstanceIdW(DeviceInfoSet, @DeviceInfoData, Buffer,
    BUFFER_SIZE, @RequiredSize) then
    Result := WideCharToString(Buffer)
  else
    Result := 'Unknown';
end;

procedure ExtractIDs(const InstanceID: string; out VendorID, DeviceID: string);
var
  VenPos, DevPos: Integer;
begin
  VendorID := 'Unknown';
  DeviceID := 'Unknown';
  VenPos := Pos('VEN_', InstanceID);
  DevPos := Pos('DEV_', InstanceID);
  if VenPos > 0 then
    VendorID := Copy(InstanceID, VenPos + 4, 4);
  if DevPos > 0 then
    DeviceID := Copy(InstanceID, DevPos + 4, 4);
end;

function GetDriverInfo(const DriverKey: string;
  out Version, DateStr: string): Boolean;
var
  Reg: TRegistry;
  RegPath: string;
begin
  Result := False;
  Version := 'N/A';
  DateStr := 'N/A';

  Reg := TRegistry.Create(KEY_READ);
  try
    Reg.RootKey := HKEY_LOCAL_MACHINE;
    RegPath := REGISTRY_BASE_PATH + DriverKey;

    if Reg.OpenKeyReadOnly(RegPath) then
    begin
      // Retrieve DriverVersion if available
      if Reg.ValueExists('DriverVersion') then
        Version := Reg.ReadString('DriverVersion');

      // Retrieve DriverDate if available
      if Reg.ValueExists('DriverDate') then
        DateStr := Reg.ReadString('DriverDate');

      // Check if at least one value was retrieved
      if (Version <> 'N/A') or (DateStr <> 'N/A') then
        Result := True;

      Reg.CloseKey;
    end;
  finally
    Reg.Free;
  end;
end;

procedure CheckVidDriverDriverPack(LogMemo: TMemo; ListView: TListView);
var
  HttpClient: THTTPClient;
  Response: IHTTPResponse;
  HTMLContent: string;
  DriverPackURL: string;
begin
  DriverPackURL :=
    'https://driverpack.io/en/hwids/PCI%5CVEN_8086%26DEV_3E92%26CC_0300?os=windows-10-x64';

  LogMemo.Lines.Add('Starting check...');
  LogMemo.Lines.Add('Querying with URL: ' + DriverPackURL);

  ListView.Clear;
  ListView.ViewStyle := vsReport;
  if ListView.Columns.Count = 0 then
    ListView.Columns.Add.Caption := 'Info';

  HttpClient := THTTPClient.Create;
  try
    // 1) Set a more realistic User-Agent
    HttpClient.CustomHeaders['User-Agent'] :=
      'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) '
      + 'Chrome/98.0.4758.102 Safari/537.36';

    // 2) Optionally add other common headers
    HttpClient.CustomHeaders['Accept'] :=
      'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8';
    HttpClient.CustomHeaders['Accept-Language'] := 'en-US,en;q=0.5';

    Response := HttpClient.Get(DriverPackURL);

    if Response.StatusCode = 200 then
    begin
      HTMLContent := Response.ContentAsString(TEncoding.UTF8);
      LogMemo.Lines.Add('Success: 200 OK. Fetched HTML content length: ' +
        HTMLContent.Length.ToString);
      // ... parse or save the HTML ...
    end
    else
    begin
      LogMemo.Lines.Add('DriverPack returned status code: ' +
        Response.StatusCode.ToString);
      LogMemo.Lines.Add('Reason: ' + Response.StatusText);
    end;

  except
    on E: Exception do
      LogMemo.Lines.Add('Error: ' + E.Message);
  end;

  HttpClient.Free;
  LogMemo.Lines.Add('Query completed.');
end;

procedure SimpleDriverPackSearch_Indy(LogMemo: TMemo);
var
  IdHTTP: TIdHTTP;
  SSLHandler: TIdSSLIOHandlerSocketOpenSSL;
  SearchURL: string;
  HTMLContent: string;
begin
  SearchURL :=
    'http://driverpack.io/en/hwids/PCI%5CVEN_8086%26DEV_3E92%26CC_0300?os=windows-10-x64';

  IdHTTP := TIdHTTP.Create(nil);
  SSLHandler := TIdSSLIOHandlerSocketOpenSSL.Create(nil);
  try
    IdHTTP.IOHandler := SSLHandler;
    IdHTTP.Request.UserAgent := 'Mozilla/5.0 (compatible; Delphi Indy)';
    IdHTTP.HandleRedirects := True;

    try
      HTMLContent := IdHTTP.Get(SearchURL);
      LogMemo.Lines.Add('Search completed (Indy). Content length: ' +
        HTMLContent.Length.ToString);

      // Optionally save to file:
      // TFile.WriteAllText('DriverPackSearch.html', HtmlContent, TEncoding.UTF8);

    except
      on E: Exception do
        LogMemo.Lines.Add('Error searching DriverPack (Indy): ' + E.Message);
    end;

  finally
    SSLHandler.Free;
    IdHTTP.Free;
  end;
end;

procedure ListAllIntelDevices(ListView: TListView; LogMemo: TMemo);
var
  VendorMapping: TJSONObject;
  DeviceInfoSet: HDEVINFO;
  DeviceInfoData: SP_DEVINFO_DATA;
  BufferW: array [0 .. 1023] of WideChar;
  RequiredSize: DWORD;
  i: Integer;
  VendorID, DeviceID, DeviceName, VendorName, DriverVersion: string;
  ListItem: TListItem;
begin
  LogMemo.Lines.Add('Scanning for installed devices (Intel only)...');

  // 1) Load & transform the JSON array into a TJSONObject of ID→Name
  VendorMapping := LoadVendorMapping('Vendor_Data.json');
  if VendorMapping = nil then
  begin
    LogMemo.Lines.Add
      ('Error: Failed to load Vendor_Data.json (array => TJSONObject).');
    Exit;
  end
  else
    LogMemo.Lines.Add('Vendor_Data.json loaded successfully.');

  try
    // 2) Prepare the ListView columns
    ListView.Clear;
    ListView.ViewStyle := vsReport;
    if ListView.Columns.Count = 0 then
    begin
      with ListView.Columns.Add do
        Caption := 'Device Name';
      Width := 200;
      with ListView.Columns.Add do
        Caption := 'Vendor ID';
      Width := 80;
      with ListView.Columns.Add do
        Caption := 'Device ID';
      Width := 80;
      with ListView.Columns.Add do
        Caption := 'Vendor Name';
      Width := 200;
      with ListView.Columns.Add do
        Caption := 'Driver Version';
      Width := 150;
    end;

    // 3) Get device info set
    FillChar(BufferW, SizeOf(BufferW), 0);
    DeviceInfoSet := SetupDiGetClassDevsW(nil, nil, 0, DIGCF_ALLCLASSES or
      DIGCF_PRESENT);
    if DeviceInfoSet = INVALID_HANDLE_VALUE then
    begin
      LogMemo.Lines.Add('Error: SetupDiGetClassDevsW failed.');
      Exit;
    end;

    try
      i := 0;
      while True do
      begin
        DeviceInfoData.cbSize := SizeOf(SP_DEVINFO_DATA);

        if not SetupDiEnumDeviceInfo(DeviceInfoSet, i, @DeviceInfoData) then
        begin
          LogMemo.Lines.Add('No more devices to enumerate. Exiting loop.');
          Break;
        end;

        Inc(i);

        // Retrieve device name (SPDRP_DEVICEDESC)
        FillChar(BufferW, SizeOf(BufferW), 0);
        if not SetupDiGetDeviceRegistryPropertyW(DeviceInfoSet, @DeviceInfoData,
          SPDRP_DEVICEDESC, nil, PBYTE(@BufferW[0]), SizeOf(BufferW),
          @RequiredSize) then
          DeviceName := 'Unknown Device'
        else
          DeviceName := WideCharToString(BufferW);

        // Retrieve instance ID => parse "VEN_xxxx" & "DEV_xxxx"
        FillChar(BufferW, SizeOf(BufferW), 0);
        if not SetupDiGetDeviceInstanceIdW(DeviceInfoSet, @DeviceInfoData,
          @BufferW[0], Length(BufferW), @RequiredSize) then
        begin
          VendorID := 'Unknown';
          DeviceID := 'Unknown';
        end
        else
        begin
          var
          InstanceID := WideCharToString(BufferW);
          var
          VendorPos := Pos('VEN_', InstanceID);
          var
          DevicePos := Pos('DEV_', InstanceID);

          if (VendorPos > 0) and (DevicePos > 0) then
          begin
            VendorID := Copy(InstanceID, VendorPos + 4, 4);
            DeviceID := Copy(InstanceID, DevicePos + 4, 4);
          end
          else
          begin
            VendorID := 'Unknown';
            DeviceID := 'Unknown';
          end;
        end;

        // 4) If not "8086" => skip non-Intel
        if not SameText(VendorID, '8086') then
          Continue; // skip

        // 5) Retrieve driver version (SPDRP_DRIVER)
        FillChar(BufferW, SizeOf(BufferW), 0);
        if not SetupDiGetDeviceRegistryPropertyW(DeviceInfoSet, @DeviceInfoData,
          SPDRP_DRIVER, nil, PBYTE(@BufferW[0]), SizeOf(BufferW), @RequiredSize)
        then
          DriverVersion := 'Unknown'
        else
          DriverVersion := WideCharToString(BufferW);

        // 6) Look up vendor name in TJSONObject
        if VendorID <> 'Unknown' then
        begin
          if VendorMapping.Values[VendorID] <> nil then
            VendorName := VendorMapping.Values[VendorID].Value
          else
            VendorName := 'Unknown Vendor';
        end
        else
          VendorName := 'Unknown Vendor';

        // 7) Log & show in ListView
        LogMemo.Lines.Add
          (Format('Intel Device Found - Dev#: %d => Name: %s, VendorID: %s, DeviceID: %s, VendorName: %s, DriverVersion: %s',
          [i, DeviceName, VendorID, DeviceID, VendorName, DriverVersion]));

        ListItem := ListView.Items.Add;
        ListItem.Caption := DeviceName;
        ListItem.SubItems.Add(VendorID);
        ListItem.SubItems.Add(DeviceID);
        ListItem.SubItems.Add(VendorName);
        ListItem.SubItems.Add(DriverVersion);
      end;

    finally
      // Destroy device info set
      SetupDiDestroyDeviceInfoList(DeviceInfoSet);
    end;

  except
    on E: Exception do
      LogMemo.Lines.Add('An unexpected error occurred in ListAllIntelDevices: '
        + E.Message);
  end;

  // Free the JSON object we built from the array
  VendorMapping.Free;

  LogMemo.Lines.Add('Intel device scan completed.');
end;

procedure ListAllDriversWithDriverVersion(ListView: TListView; LogMemo: TMemo);
var
  DeviceInfoSet: HDEVINFO;
  DeviceInfoData: SP_DEVINFO_DATA;
  BufferW: array [0 .. 1023] of WideChar;
  RequiredSize: DWORD;
  VendorID, DeviceID, DeviceName, VendorName, DriverVersion: string;
  ListItem: TListItem;
  i: Integer;
  VendorMapping: TJSONObject;
begin
  LogMemo.Lines.Add('Scanning for installed devices...');

  // Load the JSON array file and transform it into a TJSONObject
  VendorMapping := LoadVendorMapping('Vendor_Data.json');
  if VendorMapping = nil then
  begin
    LogMemo.Lines.Add('Error: Failed to load or parse Vendor_Data.json.');
    Exit;
  end
  else
    LogMemo.Lines.Add
      ('Vendor_Data.json loaded successfully (array parsed into TJSONObject).');

  try
    // (Initialize ListView columns, etc. below as normal)
    ListView.Clear;
    ListView.ViewStyle := vsReport;
    if ListView.Columns.Count = 0 then
    begin
      with ListView.Columns.Add do
        Caption := 'Device Name';
      Width := 200;
      with ListView.Columns.Add do
        Caption := 'Vendor ID';
      Width := 100;
      with ListView.Columns.Add do
        Caption := 'Device ID';
      Width := 100;
      with ListView.Columns.Add do
        Caption := 'Vendor Name';
      Width := 200;
      with ListView.Columns.Add do
        Caption := 'Driver Version';
      Width := 150;
    end;

    FillChar(BufferW, SizeOf(BufferW), 0);
    DeviceInfoSet := SetupDiGetClassDevsW(nil, nil, 0, DIGCF_ALLCLASSES or
      DIGCF_PRESENT);
    if DeviceInfoSet = INVALID_HANDLE_VALUE then
    begin
      LogMemo.Lines.Add('Error: SetupDiGetClassDevsW failed.');
      Exit;
    end;

    try
      i := 0;
      while True do
      begin
        DeviceInfoData.cbSize := SizeOf(SP_DEVINFO_DATA);

        if not SetupDiEnumDeviceInfo(DeviceInfoSet, i, @DeviceInfoData) then
        begin
          LogMemo.Lines.Add('No more devices to enumerate. Exiting loop.');
          Break;
        end;

        Inc(i);
        LogMemo.Lines.Add('Processing device index: ' + IntToStr(i));

        // ----------------------------------------------------------------
        // Retrieve Device Name
        // ----------------------------------------------------------------
        FillChar(BufferW, SizeOf(BufferW), 0);
        if not SetupDiGetDeviceRegistryPropertyW(DeviceInfoSet, @DeviceInfoData,
          SPDRP_DEVICEDESC, nil, PBYTE(@BufferW[0]), SizeOf(BufferW),
          @RequiredSize) then
        begin
          DeviceName := 'Unknown Device';
        end
        else
          DeviceName := WideCharToString(BufferW);

        // ----------------------------------------------------------------
        // Retrieve Vendor & Device IDs from instance ID
        // ----------------------------------------------------------------
        FillChar(BufferW, SizeOf(BufferW), 0);
        if not SetupDiGetDeviceInstanceIdW(DeviceInfoSet, @DeviceInfoData,
          @BufferW[0], Length(BufferW), @RequiredSize) then
        begin
          VendorID := 'Unknown';
          DeviceID := 'Unknown';
          VendorName := 'Unknown Vendor';
        end
        else
        begin
          var
          InstanceID := WideCharToString(BufferW);
          var
          VendorPos := Pos('VEN_', InstanceID);
          var
          DevicePos := Pos('DEV_', InstanceID);
          if (VendorPos > 0) and (DevicePos > 0) then
          begin
            VendorID := Copy(InstanceID, VendorPos + 4, 4);
            DeviceID := Copy(InstanceID, DevicePos + 4, 4);
          end
          else
          begin
            VendorID := 'Unknown';
            DeviceID := 'Unknown';
          end;

          // Now look up "VendorID" in VendorMapping
          if (VendorID <> 'Unknown') and (VendorMapping.Values[VendorID] <> nil)
          then
            VendorName := VendorMapping.Values[VendorID].Value
          else
            VendorName := 'Unknown Vendor';
        end;

        // ----------------------------------------------------------------
        // Retrieve Driver Version
        // ----------------------------------------------------------------
        FillChar(BufferW, SizeOf(BufferW), 0);
        if not SetupDiGetDeviceRegistryPropertyW(DeviceInfoSet, @DeviceInfoData,
          SPDRP_DRIVER, nil, PBYTE(@BufferW[0]), SizeOf(BufferW), @RequiredSize)
        then
          DriverVersion := 'Unknown'
        else
          DriverVersion := WideCharToString(BufferW);

        // ----------------------------------------------------------------
        // Log and add to ListView
        // ----------------------------------------------------------------
        LogMemo.Lines.Add
          (Format('Device: %s, VendorID: %s, DeviceID: %s, Vendor Name: %s, Driver Version: %s',
          [DeviceName, VendorID, DeviceID, VendorName, DriverVersion]));

        ListItem := ListView.Items.Add;
        ListItem.Caption := DeviceName;
        ListItem.SubItems.Add(VendorID);
        ListItem.SubItems.Add(DeviceID);
        ListItem.SubItems.Add(VendorName);
        ListItem.SubItems.Add(DriverVersion);
      end;

      if i = 0 then
        LogMemo.Lines.Add('No devices found.');
    finally
      SetupDiDestroyDeviceInfoList(DeviceInfoSet);
    end;

  except
    on E: Exception do
      LogMemo.Lines.Add('An unexpected error occurred: ' + E.Message);
  end;

  VendorMapping.Free; // free the TJSONObject built from the array
  LogMemo.Lines.Add('Device scan completed.');
end;

// -----------------------------------------------------------------------------
// Original ANSI-based procedure (unchanged)

procedure ListUnknownDrivers(ListView: TListView; LogMemo: TMemo);
const
  BUFFER_SIZE = 1024;
var
  DeviceInfoSet: HDEVINFO;
  DeviceInfoData: SP_DEVINFO_DATA;
  BufferW: array [0 .. BUFFER_SIZE - 1] of WideChar;
  RequiredSize: DWORD;
  VendorID, DeviceID, DeviceName, DeviceInstanceId, DeviceClass: string;
  Manufacturer, DriverVersion, DriverDate: string;
  DriverKey: string;
  ListItem: TListItem;
  i: Integer;
begin
  LogMemo.Lines.Add('=== ListAllDrivers: Starting device scan ===');

  // (1) Basic ListView setup
  ListView.Clear;
  ListView.ViewStyle := vsReport;
  if ListView.Columns.Count = 0 then
  begin
    with ListView.Columns.Add do
    begin
      Caption := 'Device Name';
      Width := 200;
    end;
    with ListView.Columns.Add do
    begin
      Caption := 'Vendor ID';
      Width := 100;
    end;
    with ListView.Columns.Add do
    begin
      Caption := 'Device ID';
      Width := 100;
    end;
    with ListView.Columns.Add do
    begin
      Caption := 'Class';
      Width := 150;
    end;
    with ListView.Columns.Add do
    begin
      Caption := 'Manufacturer';
      Width := 150;
    end;
    with ListView.Columns.Add do
    begin
      Caption := 'Driver Version';
      Width := 150;
    end;
    with ListView.Columns.Add do
    begin
      Caption := 'Driver Date';
      Width := 150;
    end;
  end;

  // (2) Get the device info set
  DeviceInfoSet := SetupDiGetClassDevsW(nil, nil, 0, DIGCF_ALLCLASSES or
    DIGCF_PRESENT);
  if DeviceInfoSet = INVALID_HANDLE_VALUE then
  begin
    LogMemo.Lines.Add('Error obtaining device information set.');
    Exit;
  end;

  try
    i := 0;
    while True do
    begin
      DeviceInfoData.cbSize := SizeOf(SP_DEVINFO_DATA);
      if not SetupDiEnumDeviceInfo(DeviceInfoSet, i, @DeviceInfoData) then
        Break; // no more devices
      Inc(i);

      // ... retrieve DeviceName, VendorID, DeviceID, Manufacturer, etc. ...
      // (the code you already have)

      // For demonstration, assume we've ended up with:
      // VendorID = 'Unknown' or '8086'
      // DeviceID = 'Unknown' or '3E92'
      // etc.

      // (3) If the user checked "Hide Unknown IDs," skip items with Unknown
      // if chkHideUnknown.Checked then
      begin
        if (SameText(VendorID, 'Unknown')) or (SameText(DeviceID, 'Unknown'))
        then
        begin
          // skip adding to ListView
          Continue;
        end;
      end;

      // (4) If we didn't skip, add to ListView
      ListItem := ListView.Items.Add;
      ListItem.Caption := DeviceName;
      ListItem.SubItems.Add(VendorID);
      ListItem.SubItems.Add(DeviceID);
      ListItem.SubItems.Add(DeviceClass);
      ListItem.SubItems.Add(Manufacturer);
      ListItem.SubItems.Add(DriverVersion);
      ListItem.SubItems.Add(DriverDate);
    end;

    LogMemo.Lines.Add
      (Format('Device scan completed. Total devices enumerated: %d', [i]));
  finally
    SetupDiDestroyDeviceInfoList(DeviceInfoSet);
  end;
end;

// -----------------------------------------------------------------------------

procedure ListAllDrivers(ListView: TListView; LogMemo: TMemo);
const
  BUFFER_SIZE = 1024;
var
  DeviceInfoSet: HDEVINFO;
  DeviceInfoData: SP_DEVINFO_DATA;
  BufferW: array[0..BUFFER_SIZE - 1] of WideChar;
  RequiredSize: DWORD;
  DeviceName, DeviceInstanceId, DeviceClass: string;
  VendorID, DeviceID: string;
  Manufacturer, DriverKey, DriverVersion, DriverDate: string;
  ListItem: TListItem;
  i: Integer;
  VenPos, DevPos: Integer;
begin
  LogMemo.Lines.Add('=== ListAllDrivers: Starting device scan ===');

  // Basic ListView setup with fixed column widths.
  ListView.Items.BeginUpdate;
  try
    ListView.Clear;
    ListView.ViewStyle := vsReport;
    if ListView.Columns.Count = 0 then
    begin
      with ListView.Columns.Add do
      begin
        Caption := 'Device Name';
        Width := 200;
      end;
      with ListView.Columns.Add do
      begin
        Caption := 'Vendor ID';
        Width := 100;
      end;
      with ListView.Columns.Add do
      begin
        Caption := 'Device ID';
        Width := 100;
      end;
      with ListView.Columns.Add do
      begin
        Caption := 'Class';
        Width := 150;
      end;
      with ListView.Columns.Add do
      begin
        Caption := 'Manufacturer';
        Width := 150;
      end;
      with ListView.Columns.Add do
      begin
        Caption := 'Driver Version';
        Width := 150;
      end;
      with ListView.Columns.Add do
      begin
        Caption := 'Driver Date';
        Width := 150;
      end;
    end;
  finally
    ListView.Items.EndUpdate;
  end;

  // Disable redraw to minimize flicker.
  SendMessage(ListView.Handle, WM_SETREDRAW, WPARAM(False), 0);
  try
    Form3.ProgressBar2.Min := 0;
    Form3.ProgressBar2.Position := 0;
    // We'll adjust ProgressBar2.Max dynamically as we enumerate devices.

    DeviceInfoSet := SetupDiGetClassDevsW(nil, nil, 0, DIGCF_ALLCLASSES or DIGCF_PRESENT);
    if DeviceInfoSet = INVALID_HANDLE_VALUE then
    begin
      LogMemo.Lines.Add('Error obtaining device information set.');
      Exit;
    end;

    try
      i := 0;
      while True do
      begin
        DeviceInfoData.cbSize := SizeOf(SP_DEVINFO_DATA);
        if not SetupDiEnumDeviceInfo(DeviceInfoSet, i, @DeviceInfoData) then
          Break; // no more devices
        Inc(i);

        // Retrieve device descriptive name.
        FillChar(BufferW, SizeOf(BufferW), 0);
        if not SetupDiGetDeviceRegistryPropertyW(DeviceInfoSet, @DeviceInfoData,
          SPDRP_DEVICEDESC, nil, PByte(@BufferW[0]), SizeOf(BufferW), @RequiredSize) then
        begin
          if not SetupDiGetDeviceRegistryPropertyW(DeviceInfoSet, @DeviceInfoData,
            SPDRP_FRIENDLYNAME, nil, PByte(@BufferW[0]), SizeOf(BufferW), @RequiredSize) then
            DeviceName := 'Unknown Device'
          else
            DeviceName := WideCharToString(BufferW);
        end
        else
          DeviceName := WideCharToString(BufferW);

        // Retrieve device instance ID.
        FillChar(BufferW, SizeOf(BufferW), 0);
        if SetupDiGetDeviceInstanceIdW(DeviceInfoSet, @DeviceInfoData, BufferW,
          BUFFER_SIZE, @RequiredSize) then
          DeviceInstanceId := WideCharToString(BufferW)
        else
          DeviceInstanceId := 'Unknown';

        // Parse out "VEN_xxxx" and "DEV_xxxx".
        VenPos := Pos('VEN_', DeviceInstanceId);
        DevPos := Pos('DEV_', DeviceInstanceId);
        if (VenPos > 0) and (DevPos > 0) then
        begin
          VendorID := Copy(DeviceInstanceId, VenPos + 4, 4);
          DeviceID := Copy(DeviceInstanceId, DevPos + 4, 4);
        end
        else
        begin
          VendorID := 'Unknown';
          DeviceID := 'Unknown';
        end;

        // Retrieve Class and Manufacturer.
        DeviceClass := GetDeviceProperty(DeviceInfoSet, DeviceInfoData, SPDRP_CLASS);
        Manufacturer := GetDeviceProperty(DeviceInfoSet, DeviceInfoData, SPDRP_MFG);

        // Retrieve driver key then DriverVersion and DriverDate.
        DriverKey := GetDeviceProperty(DeviceInfoSet, DeviceInfoData, SPDRP_DRIVER);
        DriverVersion := 'N/A';
        DriverDate := 'N/A';
        if DriverKey <> 'N/A' then
        begin
          if GetDriverInfo(DriverKey, DriverVersion, DriverDate) then
          begin
            // Retrieved successfully.
          end;
        end;

        // Optionally filter unknown IDs or non-empty driver versions.
        if Form3.chkHideUnknown.Checked then
        begin
          if (SameText(VendorID, 'Unknown')) or (SameText(DeviceID, 'Unknown')) then
            Continue;
        end;
        if Form3.chkNoDriver.Checked then
        begin
          if not ((DriverVersion = 'N/A') or (DriverVersion = 'Unknown')) then
            Continue;
        end;

        // Add device to ListView.
        ListItem := ListView.Items.Add;
        ListItem.Caption := DeviceName;
        ListItem.SubItems.Add(VendorID);
        ListItem.SubItems.Add(DeviceID);
        ListItem.SubItems.Add(DeviceClass);
        ListItem.SubItems.Add(Manufacturer);
        ListItem.SubItems.Add(DriverVersion);
        ListItem.SubItems.Add(DriverDate);

        // Update progress bar.
        if i > Form3.ProgressBar2.Max then
          Form3.ProgressBar2.Max := i;
        Form3.ProgressBar2.Position := i;
        // Process messages intermittently.
        if (i mod 10) = 0 then
          Application.ProcessMessages;
      end;
      // Auto-size columns to fit content
        for I := 0 to ListView.Columns.Count - 1 do
          ListView.Columns[I].Width := -2;  // Auto-size to header and content
      LogMemo.Lines.Add('Device scan completed. Total devices enumerated: ' + IntToStr(i));
    finally
      SetupDiDestroyDeviceInfoList(DeviceInfoSet);
    end;
  finally
    // Re-enable redraw and refresh.
    SendMessage(ListView.Handle, WM_SETREDRAW, WPARAM(True), 0);
    ListView.Invalidate;
  end;
end;



// procedure ListAllDrivers(ListView: TListView; LogMemo: TMemo);
// const
// BUFFER_SIZE = 1024;
// var
// DeviceInfoSet: HDEVINFO;
// DeviceInfoData: SP_DEVINFO_DATA;
// BufferW: array[0..BUFFER_SIZE - 1] of WideChar;
// RequiredSize: DWORD;
// VendorID, DeviceID, DeviceName, DeviceInstanceID, DeviceClass: string;
// Manufacturer, DriverVersion, DriverDate: string;
// DriverKey: string;
// ListItem: TListItem;
// i: Integer;
// begin
// LogMemo.Lines.Add('=== ListAllDrivers: Starting device scan ===');
//
// // Initialize the ListView columns
// ListView.Clear;
// ListView.ViewStyle := vsReport;
// if ListView.Columns.Count = 0 then
// begin
// with ListView.Columns.Add do
// begin
// Caption := 'Device Name';
// Width := 200;
// end;
// with ListView.Columns.Add do
// begin
// Caption := 'Vendor ID';
// Width := 100;
// end;
// with ListView.Columns.Add do
// begin
// Caption := 'Device ID';
// Width := 100;
// end;
// with ListView.Columns.Add do
// begin
// Caption := 'Class';
// Width := 150;
// end;
// with ListView.Columns.Add do
// begin
// Caption := 'Manufacturer';
// Width := 150;
// end;
// with ListView.Columns.Add do
// begin
// Caption := 'Driver Version';
// Width := 150;
// end;
// with ListView.Columns.Add do
// begin
// Caption := 'Driver Date';
// Width := 150;
// end;
// end;
//
// // Clear FOriginalItems for a fresh start
// if Assigned(FOriginalItems) then
// FOriginalItems.Clear;
//
// // Get a handle to the device information set
// DeviceInfoSet := SetupDiGetClassDevsW(nil, nil, 0, DIGCF_ALLCLASSES or DIGCF_PRESENT);
// if DeviceInfoSet = INVALID_HANDLE_VALUE then
// begin
// LogMemo.Lines.Add('Error obtaining device information set.');
// Exit;
// end;
//
// try
// i := 0;
// while True do
// begin
// DeviceInfoData.cbSize := SizeOf(SP_DEVINFO_DATA);
//
// if not SetupDiEnumDeviceInfo(DeviceInfoSet, i, @DeviceInfoData) then
// begin
// // No more devices
// Break;
// end;
// Inc(i);
//
// // -----------------------------------------------
// // 1) Retrieve DeviceName (SPDRP_DEVICEDESC),
// //    fallback to SPDRP_FRIENDLYNAME
// // -----------------------------------------------
// FillChar(BufferW, SizeOf(BufferW), 0);
// if not SetupDiGetDeviceRegistryPropertyW(
// DeviceInfoSet,
// @DeviceInfoData,
// SPDRP_DEVICEDESC,
// nil,
// PBYTE(@BufferW[0]),
// SizeOf(BufferW),
// @RequiredSize
// ) then
// begin
// // Try SPDRP_FRIENDLYNAME
// if not SetupDiGetDeviceRegistryPropertyW(
// DeviceInfoSet,
// @DeviceInfoData,
// SPDRP_FRIENDLYNAME,
// nil,
// PBYTE(@BufferW[0]),
// SizeOf(BufferW),
// @RequiredSize
// ) then
// DeviceName := 'Unknown Device'
// else
// DeviceName := WideCharToString(BufferW);
// end
// else
// DeviceName := WideCharToString(BufferW);
//
// // Debug log
// LogMemo.Lines.Add(Format('Device %d: Name=%s',[i, DeviceName]));
//
// // -----------------------------------------------
// // 2) Retrieve Device Instance ID => parse VendorID / DeviceID
// // -----------------------------------------------
// FillChar(BufferW, SizeOf(BufferW), 0);
// if SetupDiGetDeviceInstanceIdW(
// DeviceInfoSet,
// @DeviceInfoData,
// BufferW,
// BUFFER_SIZE,
// @RequiredSize
// ) then
// begin
// DeviceInstanceID := WideCharToString(BufferW);
// end
// else
// begin
// DeviceInstanceID := 'Unknown';
// end;
//
// // Debug log
// LogMemo.Lines.Add('  DeviceInstanceID=' + DeviceInstanceID);
//
// // parse out VEN_xxxx and DEV_xxxx
// var VenPos := Pos('VEN_', DeviceInstanceID);
// var DevPos := Pos('DEV_', DeviceInstanceID);
// if (VenPos > 0) and (DevPos > 0) then
// begin
// VendorID := Copy(DeviceInstanceID, VenPos + 4, 4);
// DeviceID := Copy(DeviceInstanceID, DevPos + 4, 4);
// end else
// begin
// VendorID := 'Unknown';
// DeviceID := 'Unknown';
// end;
//
// // Debug log
// LogMemo.Lines.Add(Format('  VendorID=%s, DeviceID=%s',[VendorID, DeviceID]));
//
// // -----------------------------------------------
// // 3) Retrieve DeviceClass via SPDRP_CLASS
// // -----------------------------------------------
// DeviceClass := GetDeviceProperty(DeviceInfoSet, DeviceInfoData, SPDRP_CLASS);
// LogMemo.Lines.Add('  Class=' + DeviceClass);
//
// // -----------------------------------------------
// // 4) Retrieve Manufacturer via SPDRP_MFG
// // -----------------------------------------------
// Manufacturer := GetDeviceProperty(DeviceInfoSet, DeviceInfoData, SPDRP_MFG);
// LogMemo.Lines.Add('  Manufacturer=' + Manufacturer);
//
// // -----------------------------------------------
// // 5) Retrieve driver key -> registry => version/date
// // -----------------------------------------------
// DriverKey := GetDeviceProperty(DeviceInfoSet, DeviceInfoData, SPDRP_DRIVER);
// DriverVersion := 'N/A';
// DriverDate := 'N/A';
//
// if DriverKey <> 'N/A' then
// begin
// if GetDriverInfo(DriverKey, DriverVersion, DriverDate) then
// begin
// // success
// end
// else
// begin
// // we skip reading from driver files, etc.
// end;
// end;
// LogMemo.Lines.Add(Format('  DriverKey=%s, DriverVersion=%s, DriverDate=%s',
// [DriverKey, DriverVersion, DriverDate]));
//
// // -----------------------------------------------
// // 6) Add to ListView
// // -----------------------------------------------
// ListItem := ListView.Items.Add;
// ListItem.Caption := DeviceName;
// ListItem.SubItems.Add(VendorID);
// ListItem.SubItems.Add(DeviceID);
// ListItem.SubItems.Add(DeviceClass);
// ListItem.SubItems.Add(Manufacturer);
// ListItem.SubItems.Add(DriverVersion);
// ListItem.SubItems.Add(DriverDate);
//
// // Also store in FOriginalItems so we can filter later
// if Assigned(FOriginalItems) then
// begin
// FOriginalItems.Add(
// DeviceName + '|' + VendorID + '|' + DeviceID + '|' +
// DeviceClass + '|' + Manufacturer + '|' + DriverVersion + '|' + DriverDate
// );
// end;
// end;
//
// LogMemo.Lines.Add(Format('Device scan completed. Total devices found: %d',[i]));
// finally
// SetupDiDestroyDeviceInfoList(DeviceInfoSet);
// end;
// end;
//
//
/// / -----------------------------------------------------------------------------
/// / Remaining procedures from your code (unchanged)
/// / -----------------------------------------------------------------------------

// procedure ListAllDrivers(ListView: TListView; LogMemo: TMemo);
// const
// BUFFER_SIZE = 1024;
// var
// DeviceInfoSet: HDEVINFO;
// DeviceInfoData: SP_DEVINFO_DATA;
// BufferW: array[0..BUFFER_SIZE - 1] of WideChar;
// RequiredSize: DWORD;
// VendorID, DeviceID, DeviceName, DeviceInstanceID, DeviceClass: string;
// Manufacturer, DriverVersion, DriverDate: string;
// DriverKey: string;
// ListItem: TListItem;
// i: Integer;
// begin
// LogMemo.Lines.Add('=== ListAllDrivers: Starting device scan ===');
//
// // Initialize the ListView columns
// ListView.Clear;
// ListView.ViewStyle := vsReport;
// if ListView.Columns.Count = 0 then
// begin
// with ListView.Columns.Add do
// begin
// Caption := 'Device Name';
// Width := 200;
// end;
// with ListView.Columns.Add do
// begin
// Caption := 'Vendor ID';
// Width := 100;
// end;
// with ListView.Columns.Add do
// begin
// Caption := 'Device ID';
// Width := 100;
// end;
// with ListView.Columns.Add do
// begin
// Caption := 'Class';
// Width := 150;
// end;
// with ListView.Columns.Add do
// begin
// Caption := 'Manufacturer';
// Width := 150;
// end;
// with ListView.Columns.Add do
// begin
// Caption := 'Driver Version';
// Width := 150;
// end;
// with ListView.Columns.Add do
// begin
// Caption := 'Driver Date';
// Width := 150;
// end;
// end;
//
// // Clear FOriginalItems for a fresh start
// if Assigned(FOriginalItems) then
// FOriginalItems.Clear;
//
// // Get a handle to the device information set
// DeviceInfoSet := SetupDiGetClassDevsW(nil, nil, 0, DIGCF_ALLCLASSES or DIGCF_PRESENT);
// if DeviceInfoSet = INVALID_HANDLE_VALUE then
// begin
// LogMemo.Lines.Add('Error obtaining device information set.');
// Exit;
// end;
//
// try
// i := 0;
// while True do
// begin
// DeviceInfoData.cbSize := SizeOf(SP_DEVINFO_DATA);
//
// if not SetupDiEnumDeviceInfo(DeviceInfoSet, i, @DeviceInfoData) then
// begin
// // No more devices
// Break;
// end;
// Inc(i);
//
// // -----------------------------------------------
// // 1) Retrieve DeviceName (SPDRP_DEVICEDESC),
// //    fallback to SPDRP_FRIENDLYNAME
// // -----------------------------------------------
// FillChar(BufferW, SizeOf(BufferW), 0);
// if not SetupDiGetDeviceRegistryPropertyW(
// DeviceInfoSet,
// @DeviceInfoData,
// SPDRP_DEVICEDESC,
// nil,
// PBYTE(@BufferW[0]),
// SizeOf(BufferW),
// @RequiredSize
// ) then
// begin
// // Try SPDRP_FRIENDLYNAME
// if not SetupDiGetDeviceRegistryPropertyW(
// DeviceInfoSet,
// @DeviceInfoData,
// SPDRP_FRIENDLYNAME,
// nil,
// PBYTE(@BufferW[0]),
// SizeOf(BufferW),
// @RequiredSize
// ) then
// DeviceName := 'Unknown Device'
// else
// DeviceName := WideCharToString(BufferW);
// end
// else
// DeviceName := WideCharToString(BufferW);
//
// // Debug log
// LogMemo.Lines.Add(Format('Device %d: Name=%s',[i, DeviceName]));
//
// // -----------------------------------------------
// // 2) Retrieve Device Instance ID => parse VendorID / DeviceID
// // -----------------------------------------------
// FillChar(BufferW, SizeOf(BufferW), 0);
// if SetupDiGetDeviceInstanceIdW(
// DeviceInfoSet,
// @DeviceInfoData,
// BufferW,
// BUFFER_SIZE,
// @RequiredSize
// ) then
// begin
// DeviceInstanceID := WideCharToString(BufferW);
// end
// else
// begin
// DeviceInstanceID := 'Unknown';
// end;
//
// // Debug log
// LogMemo.Lines.Add('  DeviceInstanceID=' + DeviceInstanceID);
//
// // parse out VEN_xxxx and DEV_xxxx
// var VenPos := Pos('VEN_', DeviceInstanceID);
// var DevPos := Pos('DEV_', DeviceInstanceID);
// if (VenPos > 0) and (DevPos > 0) then
// begin
// VendorID := Copy(DeviceInstanceID, VenPos + 4, 4);
// DeviceID := Copy(DeviceInstanceID, DevPos + 4, 4);
// end else
// begin
// VendorID := 'Unknown';
// DeviceID := 'Unknown';
// end;
//
// // Debug log
// LogMemo.Lines.Add(Format('  VendorID=%s, DeviceID=%s',[VendorID, DeviceID]));
//
// // -----------------------------------------------
// // 3) Retrieve DeviceClass via SPDRP_CLASS
// // -----------------------------------------------
// DeviceClass := GetDeviceProperty(DeviceInfoSet, DeviceInfoData, SPDRP_CLASS);
// LogMemo.Lines.Add('  Class=' + DeviceClass);
//
// // -----------------------------------------------
// // 4) Retrieve Manufacturer via SPDRP_MFG
// // -----------------------------------------------
// Manufacturer := GetDeviceProperty(DeviceInfoSet, DeviceInfoData, SPDRP_MFG);
// LogMemo.Lines.Add('  Manufacturer=' + Manufacturer);
//
// // -----------------------------------------------
// // 5) Retrieve driver key -> registry => version/date
// // -----------------------------------------------
// DriverKey := GetDeviceProperty(DeviceInfoSet, DeviceInfoData, SPDRP_DRIVER);
// DriverVersion := 'N/A';
// DriverDate := 'N/A';
//
// if DriverKey <> 'N/A' then
// begin
// if GetDriverInfo(DriverKey, DriverVersion, DriverDate) then
// begin
// // success
// end
// else
// begin
// // we skip reading from driver files, etc.
// end;
// end;
// LogMemo.Lines.Add(Format('  DriverKey=%s, DriverVersion=%s, DriverDate=%s',
// [DriverKey, DriverVersion, DriverDate]));
//
// // -----------------------------------------------
// // 6) Add to ListView
// // -----------------------------------------------
// ListItem := ListView.Items.Add;
// ListItem.Caption := DeviceName;
// ListItem.SubItems.Add(VendorID);
// ListItem.SubItems.Add(DeviceID);
// ListItem.SubItems.Add(DeviceClass);
// ListItem.SubItems.Add(Manufacturer);
// ListItem.SubItems.Add(DriverVersion);
// ListItem.SubItems.Add(DriverDate);
//
// // Also store in FOriginalItems so we can filter later
// if Assigned(FOriginalItems) then
// begin
// FOriginalItems.Add(
// DeviceName + '|' + VendorID + '|' + DeviceID + '|' +
// DeviceClass + '|' + Manufacturer + '|' + DriverVersion + '|' + DriverDate
// );
// end;
// end;
//
// LogMemo.Lines.Add(Format('Device scan completed. Total devices found: %d',[i]));
// finally
// SetupDiDestroyDeviceInfoList(DeviceInfoSet);
// end;
// end;
//
//
/// / -----------------------------------------------------------------------------
/// / Remaining procedures from your code (unchanged)
/// / -----------------------------------------------------------------------------
// procedure PostDataWithExceptionHandling(LogMemo: TMemo);
// var
// IdHTTP: TIdHTTP;
// SSLHandler: TIdSSLIOHandlerSocketOpenSSL;
// Params: TStringList;
// Response: string;
// begin
// LogMemo.Lines.Add('Starting POST operation...');
//
// IdHTTP := TIdHTTP.Create(nil);
// SSLHandler := TIdSSLIOHandlerSocketOpenSSL.Create(nil);
// Params := TStringList.Create;
// try
// IdHTTP.IOHandler := SSLHandler;
// IdHTTP.Request.ContentType := 'application/x-www-form-urlencoded';
//
// // Add your POST parameters
// Params.Add('param1=value1');
// Params.Add('param2=value2');
//
// try
// // Make the POST request
// Response := IdHTTP.Post('https://example.com/api', Params);
// LogMemo.Lines.Add('POST Response: ' + Response);
// except
// on E: EIdHTTPProtocolException do
// LogMemo.Lines.Add('HTTP Error: ' + E.Message);
// on E: Exception do
// LogMemo.Lines.Add('Error: ' + E.Message);
// end;
// finally
// Params.Free;
// SSLHandler.Free;
// IdHTTP.Free;
// end;
//
// LogMemo.Lines.Add('POST operation completed.');
// end;
procedure CheckDriverPackURL(const AURL: string; LogMemo: TMemo);
var
  HttpClient: THTTPClient;
  CookieManager: TCookieManager;
  Response: IHTTPResponse;
  HTMLContent: string;
begin
  LogMemo.Lines.Add('Querying: ' + AURL);

  // Prepare HTTPClient
  HttpClient := THTTPClient.Create;
  try
    // Cookie support
    CookieManager := TCookieManager.Create;
    HttpClient.CookieManager := CookieManager;
    HttpClient.AllowCookies := True;
    HttpClient.HandleRedirects := True;

    // Add headers to mimic a real browser
    HttpClient.CustomHeaders['User-Agent'] :=
      'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 ' +
      '(KHTML, like Gecko) Chrome/115.0.0.0 Safari/537.36';
    HttpClient.CustomHeaders['Accept'] :=
      'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8';
    HttpClient.CustomHeaders['Accept-Language'] := 'en-US,en;q=0.9';

    // Automatic decompression, if your Delphi version supports it:
    HttpClient.AcceptEncoding := 'gzip, deflate, br';
    HttpClient.AutomaticDecompression := [THTTPCompressionMethod.gZip,
      THTTPCompressionMethod.Deflate];

    try
      // Make the request
      Response := HttpClient.Get(AURL);

      // Check status code
      if Response.StatusCode = 200 then
      begin
        HTMLContent := Response.ContentAsString(TEncoding.UTF8);
        LogMemo.Lines.Add('Fetched HTML. Length = ' +
          HTMLContent.Length.ToString);

        // You can parse the HTML content here
        // For example, save or search for device names, etc.

      end
      else
      begin
        LogMemo.Lines.Add('Non-200 status: ' + Response.StatusCode.ToString);
        LogMemo.Lines.Add('StatusText: ' + Response.StatusText);
      end;

    except
      on E: Exception do
        LogMemo.Lines.Add('Error fetching ' + AURL + ': ' + E.Message);
    end;

  finally
    HttpClient.Free;
  end;
end;

/// ////////////////////////////////////////////////////////////////////////////////
procedure CheckDriverPack(LogMemo: TMemo; ListView: TListView);
var
  HttpClient: THTTPClient;
  CookieManager: TCookieManager;
  Response: IHTTPResponse;
  HTMLContent: string;
  DeviceName, TitleText, DescriptionText: string;
  ListItem: TListItem;

  function ExtractHTMLTitle(const Source: string): string;
  var
    StartPos, EndPos: Integer;
    LowerSrc: string;
  begin
    Result := '';
    LowerSrc := LowerCase(Source);
    StartPos := Pos('<title>', LowerSrc);
    if StartPos > 0 then
    begin
      EndPos := PosEx('</title>', LowerSrc, StartPos);
      if (EndPos > 0) and (EndPos > StartPos) then
      begin
        // length of <title> is 7
        StartPos := StartPos + 7;
        Result := Trim(Copy(Source, StartPos, EndPos - StartPos));
      end;
    end;
    if Result = '' then
      Result := 'Unknown Title';
  end;

  function ExtractMetaContent(const Source, MetaName: string): string;
  var
    StartPos, EndPos: Integer;
    TagPattern: string;
  begin
    // Looking for something like: <meta name="MetaName" content="..." />
    TagPattern := Format('name="%s" content="', [MetaName]);
    StartPos := Pos(TagPattern, Source);
    if StartPos > 0 then
    begin
      StartPos := StartPos + Length(TagPattern);
      EndPos := PosEx('"', Source, StartPos);
      if EndPos > StartPos then
        Result := Copy(Source, StartPos, EndPos - StartPos)
      else
        Result := '';
    end
    else
      Result := 'Unknown';
  end;

const
  DRIVERPACK_URL =
    'https://driverpack.io/en/hwids/PCI%5CVEN_8086%26DEV_3E92%26CC_0300?os=windows-10-x64';
begin
  // Log what we’re querying
  LogMemo.Lines.Add('Querying: ' + DRIVERPACK_URL);

  // Prepare the ListView
  ListView.Clear;
  ListView.ViewStyle := vsReport;
  if ListView.Columns.Count = 0 then
  begin
    ListView.Columns.Add.Caption := 'Device Name';
    ListView.Columns.Add.Caption := 'Description';
  end;

  HttpClient := THTTPClient.Create;
  try
    // If your Delphi version supports cookies, use a TCookieManager
    CookieManager := TCookieManager.Create;
    HttpClient.CookieManager := CookieManager;
    HttpClient.HandleRedirects := True;
    HttpClient.AllowCookies := True;

    // Add headers to pretend to be a common browser
    HttpClient.CustomHeaders['User-Agent'] :=
      'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 ' +
      '(KHTML, like Gecko) Chrome/115.0.0.0 Safari/537.36';
    HttpClient.CustomHeaders['Accept'] :=
      'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8';
    HttpClient.CustomHeaders['Accept-Language'] := 'en-US,en;q=0.9';
    // Optionally set HttpClient.Referer := 'https://google.com'; // sometimes helps

    // Automatic decompression, if supported
    HttpClient.AcceptEncoding := 'gzip, deflate, br';
    HttpClient.AutomaticDecompression := [THTTPCompressionMethod.gZip,
      THTTPCompressionMethod.Deflate];

    try
      // Attempt GET
      Response := HttpClient.Get(DRIVERPACK_URL);

      // Check the HTTP status code
      if Response.StatusCode = 200 then
      begin
        // Extract the HTML
        HTMLContent := Response.ContentAsString(TEncoding.UTF8);
        LogMemo.Lines.Add('Fetched HTML. Length = ' +
          HTMLContent.Length.ToString);

        // (Optional) Save the HTML for debugging
        try
          TFile.WriteAllText('DriverPack_8086_3E92.html', HTMLContent,
            TEncoding.UTF8);
          LogMemo.Lines.Add('Saved to DriverPack_8086_3E92.html');
        except
          on E: Exception do
            LogMemo.Lines.Add('Error saving HTML: ' + E.Message);
        end;

        // 1) Extract <title>
        TitleText := ExtractHTMLTitle(HTMLContent);
        LogMemo.Lines.Add('Title: ' + TitleText);

        // 2) Extract <meta name="description">
        DescriptionText := ExtractMetaContent(HTMLContent, 'description');
        LogMemo.Lines.Add('Description: ' + DescriptionText);

        // 3) Simple logic to detect “UHD Graphics 630”
        if Pos('UHD Graphics 630', DescriptionText) > 0 then
          DeviceName := 'UHD Graphics 630 (Desktop)'
        else
          DeviceName := 'Unknown Device';

        // 4) Display in ListView
        ListItem := ListView.Items.Add;
        ListItem.Caption := DeviceName;
        ListItem.SubItems.Add(DescriptionText);
      end
      else
      begin
        // Non-200: maybe 403 or 404
        LogMemo.Lines.Add('Non-200 status: ' + Response.StatusCode.ToString);
        LogMemo.Lines.Add('StatusText: ' + Response.StatusText);
      end;

    except
      on E: Exception do
      begin
        LogMemo.Lines.Add('Error fetching ' + DRIVERPACK_URL + ': ' +
          E.Message);
      end;
    end;

  finally
    HttpClient.Free;
  end;
end;

/// //////////////////////////////////////////////////////////////////////

procedure IndyCheckDriverPack;
var
  IdHTTP: TIdHTTP;
  SSLHandler: TIdSSLIOHandlerSocketOpenSSL;
  ZLib: TIdCompressorZLib;
  Cookies: TIdCookieManager;
  HTML: string;
  URL: string;
begin
  IdHTTP := TIdHTTP.Create(nil);
  SSLHandler := TIdSSLIOHandlerSocketOpenSSL.Create(nil);
  ZLib := TIdCompressorZLib.Create(nil);
  Cookies := TIdCookieManager.Create(nil);
  try
    // Basic Indy plumbing
    IdHTTP.IOHandler := SSLHandler;
    IdHTTP.Compressor := ZLib;
    IdHTTP.CookieManager := Cookies;

    IdHTTP.HandleRedirects := True;
    IdHTTP.Request.Connection := 'keep-alive';

    // SSL options
    SSLHandler.SSLOptions.Method := sslvTLSv1_2;
    SSLHandler.SSLOptions.Mode := sslmClient;

    // We try to mimic a modern Chrome on Windows
    IdHTTP.Request.UserAgent :=
      'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 ' +
      '(KHTML, like Gecko) Chrome/115.0.0.0 Safari/537.36';

    // Common headers to appear “less suspicious”
    IdHTTP.Request.Accept :=
      'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8';
    IdHTTP.Request.AcceptEncoding := 'gzip, deflate, br';
    IdHTTP.Request.AcceptLanguage := 'en-US,en;q=0.9';
    IdHTTP.Request.Referer := 'https://driverpack.io/';

    // Attempt #1: direct GET on the main page
    URL := 'https://driverpack.io/';
    try
      HTML := IdHTTP.Get(URL);
      // If it worked, you can inspect the HTML
      ShowMessage('Success: main page length = ' + HTML.Length.ToString);
    except
      on E: Exception do
        ShowMessage('Optional step: Could not get main page - ' + E.Message);
    end;

    // Attempt #2: hardware-specific page
    URL := 'https://driverpack.io/en/hwids/PCI%5CVEN_8086%26DEV_3E92%26CC_0300?os=windows-10-x64';
    try
      HTML := IdHTTP.Get(URL);
      // If 200 OK, you can parse the HTML here
      ShowMessage('Success: target page length = ' + HTML.Length.ToString);
    except
      on E: EIdHTTPProtocolException do
      begin
        ShowMessage('HTTP Error: ' + E.Message + sLineBreak + 'Status code: ' +
          IntToStr(E.ErrorCode));
      end;
      on E: Exception do
      begin
        ShowMessage('Error: ' + E.ClassName + ' - ' + E.Message);
      end;
    end;

  finally
    IdHTTP.Free;
    ZLib.Free;
    Cookies.Free;
    SSLHandler.Free;
  end;
end;

procedure CheckDeviceKB_Vendor8086_Dev3E92(LogMemo: TMemo; ListView: TListView);
var
  HttpClient: THTTPClient;
  Response: IHTTPResponse;
  HTMLContent: string;
  DeviceName, TitleText, DescriptionText: string;
  ListItem: TListItem;

  function ExtractMetaContent(const Source, MetaName: string): string;
  var
    StartPos, EndPos: Integer;
    TagPattern: string;
  begin
    TagPattern := Format('name="%s" content="', [MetaName]);
    StartPos := Pos(TagPattern, Source);
    if StartPos > 0 then
    begin
      StartPos := StartPos + Length(TagPattern);
      EndPos := PosEx('"', Source, StartPos);
      if EndPos > StartPos then
        Result := Copy(Source, StartPos, EndPos - StartPos)
      else
        Result := '';
    end
    else
      Result := 'Unknown';
  end;

// A quick helper to find <title> ... </title>
  function ExtractHTMLTitle(const Source: string): string;
  var
    StartPos, EndPos: Integer;
  begin
    Result := '';
    StartPos := Pos('<title>', LowerCase(Source));
    if StartPos > 0 then
    begin
      EndPos := PosEx('</title>', LowerCase(Source), StartPos);
      if (EndPos > 0) and (EndPos > StartPos) then
      begin
        // length of <title> is 7
        StartPos := StartPos + 7;
        Result := Trim(Copy(Source, StartPos, EndPos - StartPos));
      end;
    end;
    if Result = '' then
      Result := 'Unknown Title';
  end;

const
  URL = 'https://www.devicekb.com/hardware/pci-vendors/ven_8086-dev_15b8';
  // URL = 'https://www.devicekb.com/hardware/usb-vendors/ven_8086-dev_3E92';
  // URL = 'https://www.devicekb.com/hardware/pci-vendors/ven_8086-dev_3e92';
begin
  LogMemo.Lines.Add('Querying: ' + URL);

  // Prepare ListView
  ListView.Clear;
  ListView.ViewStyle := vsReport;
  if ListView.Columns.Count = 0 then
  begin
    ListView.Columns.Add.Caption := 'Device Name';
    ListView.Columns.Add.Caption := 'Description';
  end;

  HttpClient := THTTPClient.Create;
  try
    try
      Response := HttpClient.Get(URL);
      HTMLContent := Response.ContentAsString(TEncoding.UTF8);

      if Response.StatusCode = 200 then
      begin
        LogMemo.Lines.Add('Fetched HTML. Length = ' +
          HTMLContent.Length.ToString);

        // Save for debugging if you like
        try
          TFile.WriteAllText('DeviceKB_8086_3E92.html', HTMLContent,
            TEncoding.UTF8);
          LogMemo.Lines.Add('Saved to DeviceKB_8086_3E92.html');
        except
          on E: Exception do
            LogMemo.Lines.Add('Error saving HTML: ' + E.Message);
        end;

        // 1) Extract the <title> text
        TitleText := ExtractHTMLTitle(HTMLContent);
        LogMemo.Lines.Add('Title: ' + TitleText);

        // 2) Extract the <meta name="description" ... >
        DescriptionText := ExtractMetaContent(HTMLContent, 'description');
        LogMemo.Lines.Add('Description: ' + DescriptionText);

        // 3) Optionally parse out “UHD Graphics 630 (Desktop)” from the description,
        // or from <title>, or from <meta name="keywords">.
        // For example, if you want the device name specifically:
        // If your “description” is
        // "PCI hardware id PCI\VEN_8086&DEV_3E92 or PCI device name UHD Graphics 630..."
        // you can do a simple search for "UHD Graphics 630"

        if Pos('UHD Graphics 630', DescriptionText) > 0 then
          DeviceName := 'UHD Graphics 630 (Desktop)'
        else
          DeviceName := 'Unknown Device';

        // 4) Show in ListView
        ListItem := ListView.Items.Add;
        ListItem.Caption := DeviceName;
        ListItem.SubItems.Add(DescriptionText);

        // If you want more data in more columns, add them here
        // e.g. parse <meta name="keywords" ... >, or other text.
      end
      else
      begin
        LogMemo.Lines.Add('Non-200 status: ' + Response.StatusCode.ToString);
        LogMemo.Lines.Add('StatusText: ' + Response.StatusText);
      end;

    except
      on E: Exception do
        LogMemo.Lines.Add('Error fetching ' + URL + ': ' + E.Message);
    end;
  finally
    HttpClient.Free;
  end;
end;

procedure CheckDeviceKB_Dynamic(LogMemo: TMemo; ListView: TListView;
  const AVendorID, ADeviceID: string);
var
  HttpClient: THTTPClient;
  Response: IHTTPResponse;
  HTMLContent: string;
  DeviceName, TitleText, DescriptionText: string;
  ListItem: TListItem;

  function ExtractMetaContent(const Source, MetaName: string): string;
  var
    StartPos, EndPos: Integer;
    TagPattern: string;
  begin
    // look for: <meta name="MetaName" content="...">
    TagPattern := Format('name="%s" content="', [MetaName]);
    StartPos := Pos(TagPattern, Source);
    if StartPos > 0 then
    begin
      StartPos := StartPos + Length(TagPattern);
      EndPos := PosEx('"', Source, StartPos);
      if (EndPos > StartPos) then
        Result := Copy(Source, StartPos, EndPos - StartPos)
      else
        Result := '';
    end
    else
      Result := 'Unknown';
  end;

// finds text between <title> and </title>
  function ExtractHTMLTitle(const Source: string): string;
  var
    StartPos, EndPos: Integer;
  begin
    Result := '';
    StartPos := Pos('<title>', LowerCase(Source));
    if StartPos > 0 then
    begin
      EndPos := PosEx('</title>', LowerCase(Source), StartPos);
      if (EndPos > 0) and (EndPos > StartPos) then
      begin
        // length of "<title>" is 7
        StartPos := StartPos + 7;
        Result := Trim(Copy(Source, StartPos, EndPos - StartPos));
      end;
    end;
    if Result = '' then
      Result := 'Unknown Title';
  end;

var
  URL: string;
begin
  // Build the URL for e.g.: https://www.devicekb.com/hardware/pci-vendors/ven_8086-dev_3e92
  URL := Format('https://www.devicekb.com/hardware/pci-vendors/ven_%s-dev_%s',

    [AVendorID, ADeviceID]);

  LogMemo.Lines.Add('Querying: ' + URL);

  // Then check the final URL string

  LogMemo.Lines.Add('Final URL: ' + URL);

  // Prepare the ListView
  ListView.Clear;
  ListView.ViewStyle := vsReport;
  if ListView.Columns.Count = 0 then
  begin
    ListView.Columns.Clear;
    ListView.Columns.Add.Caption := 'Device Name';
    ListView.Columns.Add.Caption := 'Description';
  end;

  HttpClient := THTTPClient.Create;
  try
    try
      // Make the HTTP GET call
      Response := HttpClient.Get(URL);
      HTMLContent := Response.ContentAsString(TEncoding.UTF8);

      if Response.StatusCode = 200 then
      begin
        LogMemo.Lines.Add('Fetched HTML. Length = ' +
          HTMLContent.Length.ToString);

        // Optionally save the HTML for debugging
        try
          TFile.WriteAllText(Format('DeviceKB_%s_%s.html',
            [AVendorID, ADeviceID]), HTMLContent, TEncoding.UTF8);
          LogMemo.Lines.Add(Format('Saved to DeviceKB_%s_%s.html',
            [AVendorID, ADeviceID]));
        except
          on E: Exception do
            LogMemo.Lines.Add('Error saving HTML: ' + E.Message);
        end;

        // 1) Extract the <title> text
        TitleText := ExtractHTMLTitle(HTMLContent);
        LogMemo.Lines.Add('Title: ' + TitleText);

        // 2) Extract the <meta name="description">
        DescriptionText := ExtractMetaContent(HTMLContent, 'description');
        LogMemo.Lines.Add('Description: ' + DescriptionText);

        // 3) Same logic: if "UHD Graphics 630" is found, call it "UHD Graphics 630 (Desktop)"
        // otherwise, call it "Unknown Device"
        if Pos('UHD Graphics 630', DescriptionText) > 0 then
          DeviceName := 'UHD Graphics 630 (Desktop)'
        else
          DeviceName := 'Unknown Device';

        // 4) Show results in ListView
        ListItem := ListView.Items.Add;
        ListItem.Caption := DeviceName;
        ListItem.SubItems.Add(DescriptionText);

      end
      else
      begin
        LogMemo.Lines.Add('Non-200 status: ' + Response.StatusCode.ToString);
        LogMemo.Lines.Add('StatusText: ' + Response.StatusText);
      end;

    except
      on E: Exception do
      begin
        LogMemo.Lines.Add('Error fetching ' + URL + ': ' + E.Message);
      end;
    end;
  finally
    HttpClient.Free;
  end;
end;

procedure CheckVidDriver(LogMemo: TMemo; ListView: TListView);
var
  HttpClient: THTTPClient;
  Response: IHTTPResponse;
  HTMLContent, TempStr: string;
  DeviceName, DeviceID, VendorName, VendorID: string;
  ListItem: TListItem;
  Match: TMatch;
  VendorStart, VendorEnd: Integer;

  function ExtractMetaContent(const Source, MetaName: string): string;
  var
    StartPos, EndPos: Integer;
    TagPattern: string;
  begin
    TagPattern := Format('name="%s" content="', [MetaName]);
    StartPos := Pos(TagPattern, Source);
    if StartPos > 0 then
    begin
      StartPos := StartPos + Length(TagPattern);
      EndPos := PosEx('"', Source, StartPos);
      if EndPos > StartPos then
        Result := Copy(Source, StartPos, EndPos - StartPos)
      else
        Result := '';
    end
    else
      Result := 'Unknown';
  end;

begin
  LogMemo.Lines.Add('Starting check for UHD Graphics 630 driver...');

  const
    QueryUrl = GDeviceHuntURL;
  LogMemo.Lines.Add('Querying DeviceHunt with URL: ' + QueryUrl);

  // Configure ListView
  ListView.Items.BeginUpdate;
  try
    ListView.ViewStyle := vsReport;

    // Clear existing columns and define new ones if not already defined
    if ListView.Columns.Count = 0 then
    begin
      ListView.Columns.Clear;
      ListView.Columns.Add.Caption := 'Device Name';
      ListView.Columns.Add.Caption := 'Device ID';
      ListView.Columns.Add.Caption := 'Vendor Name';
      ListView.Columns.Add.Caption := 'Vendor ID';
      ListView.Columns[0].Width := 300;
      // Increased width to accommodate longer names
      ListView.Columns[1].Width := 100;
      ListView.Columns[2].Width := 200;
      ListView.Columns[3].Width := 100;
    end;

    HttpClient := THTTPClient.Create;
    try
      try
        Response := HttpClient.Get(QueryUrl);
        HTMLContent := Response.ContentAsString(TEncoding.UTF8);

        if Response.StatusCode = 200 then
        begin
          LogMemo.Lines.Add('Successfully fetched HTML content.');

          // Optional: Save fetched HTML to a file for manual inspection
          try
            TFile.WriteAllText('FetchedHtml.html', HTMLContent, TEncoding.UTF8);
            LogMemo.Lines.Add
              ('Fetched HTML content saved to FetchedHtml.html for inspection.');
          except
            on E: Exception do
              LogMemo.Lines.Add('Error saving HTML content to file: ' +
                E.Message);
          end;

          // Extract Device Name
          DeviceName := ExtractMetaContent(HTMLContent, 'dcterms.Title');
          LogMemo.Lines.Add('Extracted DeviceName (raw): ' + DeviceName);

          // Decode HTML entities in DeviceName
          DeviceName := TNetEncoding.HTML.Decode(DeviceName);
          LogMemo.Lines.Add('Decoded DeviceName: ' + DeviceName);

          // Optionally, split the DeviceName if needed
          if Pos('-', DeviceName) > 0 then
          begin
            DeviceName :=
              Trim(Copy(DeviceName, Pos('-', DeviceName) + 1, MaxInt));
            LogMemo.Lines.Add('DeviceName after splitting: ' + DeviceName);
          end
          else
            LogMemo.Lines.Add('DeviceName does not contain a hyphen (-).');

          // Extract Device ID
          TempStr := ExtractMetaContent(HTMLContent, 'dcterms.Identifier');
          LogMemo.Lines.Add('Extracted DeviceID (raw): ' + TempStr);

          if Pos('/', TempStr) > 0 then
            DeviceID := Copy(TempStr, LastDelimiter('/', TempStr) + 1, MaxInt)
          else
            DeviceID := TempStr;

          LogMemo.Lines.Add('DeviceID after extraction: ' + DeviceID);

          // Extract Vendor Name
          TempStr := ExtractMetaContent(HTMLContent, 'dcterms.Description');
          LogMemo.Lines.Add('Extracted VendorName (raw): ' + TempStr);

          if Pos('Vendor:', TempStr) > 0 then
          begin
            VendorStart := Pos('Vendor:', TempStr) + Length('Vendor:');
            VendorEnd := PosEx('/', TempStr, VendorStart);
            if VendorEnd > VendorStart then
              VendorName :=
                Trim(Copy(TempStr, VendorStart, VendorEnd - VendorStart))
            else
              VendorName := Trim(Copy(TempStr, VendorStart, MaxInt));
            LogMemo.Lines.Add('VendorName after extraction: ' + VendorName);
          end
          else
          begin
            VendorName := 'Unknown';
            LogMemo.Lines.Add('VendorName extraction failed. Set to Unknown.');
          end;

          // Extract Vendor ID using Regular Expressions
          Match := TRegEx.Match(HTMLContent, 'VEN_([0-9A-Fa-f]{4})',
            [roIgnoreCase]);
          if Match.Success then
          begin
            VendorID := UpperCase(Match.Groups[1].Value);
            LogMemo.Lines.Add('Extracted VendorID (regex): ' + VendorID);
          end
          else
          begin
            VendorID := 'Unknown';
            LogMemo.Lines.Add('VendorID extraction failed. Set to Unknown.');
          end;

          // Final Log Results
          LogMemo.Lines.Add('Device Name: ' + DeviceName);
          LogMemo.Lines.Add('Device ID: ' + DeviceID);
          LogMemo.Lines.Add('Vendor Name: ' + VendorName);
          LogMemo.Lines.Add('Vendor ID: ' + VendorID);

          // Add details to ListView
          ListItem := ListView.Items.Add;
          ListItem.Caption := DeviceName;
          ListItem.SubItems.Add(DeviceID);
          ListItem.SubItems.Add(VendorName);
          ListItem.SubItems.Add(VendorID);

          // Auto-size columns
          for var i := 0 to ListView.Columns.Count - 1 do
            ListView.Columns[i].Width := -2; // Auto-size to content
        end
        else
          LogMemo.Lines.Add('DeviceHunt API returned status code: ' +
            Response.StatusCode.ToString);
      except
        on E: Exception do
          LogMemo.Lines.Add('Error querying DeviceHunt: ' + E.Message);
      end;
    finally
      HttpClient.Free;
    end;
  finally
    ListView.Items.EndUpdate;
  end;

  LogMemo.Lines.Add('Query completed. Please review the logs.');
end;

procedure QueryDriverFromListView(TargetDriver: string; ListView: TListView;
  LogMemo: TMemo);
var
  ListItem: TListItem;
  FoundDriver: Boolean;
  QueryUrl: string;
  HttpClient: THTTPClient;
  Response: IHTTPResponse;
  HTMLContent: TStringList;
  DriverDetails: string;
begin
  LogMemo.Lines.Add('Starting to query drivers...');
  FoundDriver := False;

  for ListItem in ListView.Items do
  begin
    if SameText(ListItem.Caption, TargetDriver) then
    begin
      FoundDriver := True;
      LogMemo.Lines.Add('Driver found in ListView: ' + ListItem.Caption);
      QueryUrl := 'https://driverpack.io/en/catalog/' + TargetDriver;
      LogMemo.Lines.Add('Querying DriverPack with URL: ' + QueryUrl);

      HttpClient := THTTPClient.Create;
      HTMLContent := TStringList.Create;
      try
        Response := HttpClient.Get(QueryUrl);

        if Response.StatusCode = 200 then
        begin
          HTMLContent.Text := Response.ContentAsString;
          LogMemo.Lines.Add('Response received successfully.');

          // Example: Extract available drivers (simplified scraping)
          if HTMLContent.Text.Contains('Available drivers') then
          begin
            DriverDetails := 'Available drivers found for ' + TargetDriver;
            LogMemo.Lines.Add(DriverDetails);

            // Extract driver information (simplified parsing for logging)
            HTMLContent.SaveToFile('DriverDetails.html'); // Save for inspection
            LogMemo.Lines.Add('Driver details saved to DriverDetails.html');
          end
          else
            LogMemo.Lines.Add
              ('No available drivers section found in the response.');
        end
        else
          LogMemo.Lines.Add('DriverPack API returned status code: ' +
            Response.StatusCode.ToString);
      finally
        HttpClient.Free;
        HTMLContent.Free;
      end;

      Break; // Stop after finding the target driver
    end;
  end;

  if not FoundDriver then
    LogMemo.Lines.Add('Target driver not found in ListView: ' + TargetDriver);

  LogMemo.Lines.Add('Finished querying drivers.');
end;

procedure QueryDriverPackToListView(HardwareID: string; ListView: TListView;
  LogMemo: TMemo);
var
  HttpClient: THTTPClient;
  Response: IHTTPResponse;
  JsonResponse: TJSONObject;
  ListItem: TListItem;
begin
  HttpClient := THTTPClient.Create;
  try
    // Send HTTP GET request to DriverPack API
    Response := HttpClient.Get('https://driverpack.io/en/catalog/' +
      HardwareID);

    if Response.StatusCode = 200 then
    begin
      // Parse JSON response
      JsonResponse := TJSONObject.ParseJSONValue(Response.ContentAsString)
        as TJSONObject;
      try
        if Assigned(JsonResponse) then
        begin
          // Populate ListView
          ListView.Items.Clear;
          ListItem := ListView.Items.Add;
          ListItem.Caption := 'Driver Name: ' + JsonResponse.GetValue<string>
            ('name', 'Unknown');
          ListItem.SubItems.Add('Version: ' + JsonResponse.GetValue<string>
            ('version', 'Unknown'));
          ListItem.SubItems.Add('Vendor: ' + JsonResponse.GetValue<string>
            ('vendor', 'Unknown'));
          LogMemo.Lines.Add('Driver found in API: ' +
            JsonResponse.GetValue<string>('name', 'Unknown'));
        end
        else
          LogMemo.Lines.Add('No valid JSON response received for Hardware ID: '
            + HardwareID);
      finally
        JsonResponse.Free;
      end;
    end
    else
      LogMemo.Lines.Add('Driver not found for Hardware ID: ' + HardwareID);
  finally
    HttpClient.Free;
  end;
end;

procedure TForm3.DisplaySearchResults(const HTMLContent: string);
var
  StartPos, EndPos: Integer;
  ResultText: string;
  LItem: TListItem;
begin
  // Clear previous results
  ListView2.Items.Clear;

  // Example: Parse Google results
  StartPos := Pos('<div class="BNeawe vvjwJb AP7Wnd">', HTMLContent);
  while StartPos > 0 do
  begin
    EndPos := PosEx('</div>', HTMLContent, StartPos);
    if EndPos > 0 then
    begin
      ResultText := Copy(HTMLContent,
        StartPos + Length('<div class="BNeawe vvjwJb AP7Wnd">'),
        EndPos - StartPos - Length('<div class="BNeawe vvjwJb AP7Wnd">'));
      LItem := ListView2.Items.Add;
      LItem.Caption := ResultText;
      StartPos := PosEx('<div class="BNeawe vvjwJb AP7Wnd">',
        HTMLContent, EndPos);
    end
    else
      Break;
  end;

  if ListView2.Items.Count = 0 then
    ShowMessage('No results found.');
end;

procedure TForm3.QueryAllDrivers;
var
  i: Integer;
  HardwareID: string;
begin
  LogMemo.Lines.Add('Starting to query drivers in ListView...');

  for i := 0 to ListView1.Items.Count - 1 do
  begin
    HardwareID := ListView1.Items[i].Caption;
    // Assuming driver name is used as HardwareID
    LogMemo.Lines.Add('Querying driver: ' + HardwareID);
    QueryDriverPackToListView(HardwareID, ListView2, LogMemo);
  end;

  LogMemo.Lines.Add('Finished querying all drivers.');
end;

procedure TForm3.SearchGoogle1Click(Sender: TObject);
var
  LItem: TListItem;
  VendorID, DeviceID, QueryUrl: string;
begin
  if not Assigned(ListView1.Selected) then
  begin
    ShowMessage('No row selected!');
    Exit;
  end;

  LItem := ListView1.Selected;
  VendorID := LItem.SubItems[0];
  DeviceID := LItem.SubItems[1];
  QueryUrl := Format('https://www.google.com/search?q=PCI%%5CVEN_%s%%26DEV_%s',
    [VendorID, DeviceID]);

  ShellExecute(0, 'open', PChar(QueryUrl), nil, nil, SW_SHOWNORMAL);
end;

procedure TForm3.SearchGoogleDeviceName1Click(Sender: TObject);

var
  LItem: TListItem;
  DeviceName, EncodedName, QueryUrl: string;
begin
  if not Assigned(ListView1.Selected) then
  begin
    ShowMessage('No row selected!');
    Exit;
  end;

  // 1) Grab the first column’s text (e.g. "Intel HD Graphics 520" or whatever)
  LItem := ListView1.Selected;
  DeviceName := LItem.Caption;

  // 2) URL-encode it so spaces → “%20”, etc.
  EncodedName := TNetEncoding.URL.Encode(DeviceName);

  // 3) Build the Google search URL
  QueryUrl := 'https://www.google.com/search?q=' + EncodedName +' Driver';

  // 4) Open the default browser on that URL
  ShellExecute(Handle, 'open', PChar(QueryUrl), nil, nil, SW_SHOWNORMAL);
end;



procedure QueryDriverPackForAll(ListView: TListView; OutputListView: TListView);
var
  i: Integer;
  DriverName: string;
begin
  // Clear the output ListView
  OutputListView.Items.Clear;

  // Set up columns in the output ListView if not already done
  OutputListView.ViewStyle := vsReport;
  if OutputListView.Columns.Count = 0 then
  begin
    with OutputListView.Columns.Add do
    begin
      Caption := 'Driver Name';
      Width := 150;
    end;
    with OutputListView.Columns.Add do
    begin
      Caption := 'Version';
      Width := 100;
    end;
    with OutputListView.Columns.Add do
    begin
      Caption := 'Vendor';
      Width := 200;
    end;
  end;

  // Iterate through the drivers in the ListView
  for i := 0 to ListView.Items.Count - 1 do
  begin
    DriverName := ListView.Items[i].Caption;
    // Get the driver name or hardware ID
    try
      QueryDriverPackToListView(DriverName, OutputListView, Form3.LogMemo);
    except
      on E: Exception do
        ShowMessage('Error querying DriverPack for: ' + DriverName + ' - ' +
          E.Message);
    end;
  end;
end;

procedure ListSystemDriversListView(ListView: TListView; LogMemo: TMemo;
  ProgressBar: TProgressBar);
var
  WbemLocator: OLEVariant;
  WMIService: OLEVariant;
  DriverList: OLEVariant;
  Driver: OLEVariant;
  Enum: IEnumVariant;
  IValue: Cardinal;
  ListItem: TListItem;
  Col, Row, MaxWidth, TextWidth: Integer;
  ColumnText: string;
  QueryUrl: string;
  HttpClient: THTTPClient;
  Response: IHTTPResponse;
  JsonResponse: TJSONObject;
  DriverCount, ProcessedDrivers: Integer;
begin
  ListView.Items.Clear;

  ListView.ViewStyle := vsReport;
  if ListView.Columns.Count = 0 then
  begin
    with ListView.Columns.Add do
    begin
      Caption := 'Driver Name';
      Width := 150;
    end;
    with ListView.Columns.Add do
    begin
      Caption := 'State';
      Width := 100;
    end;
    with ListView.Columns.Add do
    begin
      Caption := 'Description';
      Width := 200;
    end;
  end;

  LogMemo.Lines.Clear;

  try
    CoInitialize(nil);
    try
      WbemLocator := CreateOleObject('WbemScripting.SWbemLocator');
      WMIService := WbemLocator.ConnectServer('.', 'root\CIMV2');

      DriverList := WMIService.ExecQuery
        ('SELECT Name, State, Description FROM Win32_SystemDriver', 'WQL', 0);

      DriverCount := DriverList.Count;
      ProgressBar.Max := DriverCount;
      ProgressBar.Position := 0;
      ProcessedDrivers := 0;

      Enum := IUnknown(DriverList._NewEnum) as IEnumVariant;
      while Enum.Next(1, Driver, IValue) = 0 do
      begin
        Inc(ProcessedDrivers);
        ProgressBar.Position := ProcessedDrivers;

        ListItem := ListView.Items.Add;
        ListItem.Caption := VarToStr(Driver.Name);
        ListItem.SubItems.Add(VarToStr(Driver.State));
        ListItem.SubItems.Add(VarToStr(Driver.Description));
        LogMemo.Lines.Add('Driver Found: ' + VarToStr(Driver.Name));

        QueryUrl := 'https://driverpack.io/en/search?query=' +
          VarToStr(Driver.Name);
        LogMemo.Lines.Add('Querying DriverPack API with URL: ' + QueryUrl);

        HttpClient := THTTPClient.Create;
        try
          HttpClient.CustomHeaders['User-Agent'] := 'Mozilla/5.0';
          HttpClient.CustomHeaders['Accept-Language'] := 'en-US';

          Response := HttpClient.Get(QueryUrl);
          if Response.StatusCode = 200 then
          begin
            JsonResponse := TJSONObject.ParseJSONValue(Response.ContentAsString)
              as TJSONObject;
            try
              if Assigned(JsonResponse) then
                LogMemo.Lines.Add('DriverPack Response: ' +
                  JsonResponse.ToString)
              else
                LogMemo.Lines.Add('No valid JSON response received.');
            finally
              JsonResponse.Free;
            end;
          end
          else
            LogMemo.Lines.Add('API returned status code: ' +
              Response.StatusCode.ToString);
        except
          on E: Exception do
            LogMemo.Lines.Add('HTTP Request Error: ' + E.Message);
        end;
        HttpClient.Free;

        Driver := Unassigned;
      end;

      if ListView.Items.Count = 0 then
      begin
        ListItem := ListView.Items.Add;
        ListItem.Caption := 'No drivers found.';
        LogMemo.Lines.Add('No drivers found.');
      end;

      for Col := 0 to ListView.Columns.Count - 1 do
      begin
        MaxWidth := ListView.Canvas.TextWidth
          (ListView.Columns[Col].Caption) + 10;
        for Row := 0 to ListView.Items.Count - 1 do
        begin
          if Col = 0 then
            ColumnText := ListView.Items[Row].Caption
          else
            ColumnText := ListView.Items[Row].SubItems[Col - 1];
          TextWidth := ListView.Canvas.TextWidth(ColumnText) + 10;
          if TextWidth > MaxWidth then
            MaxWidth := TextWidth;
        end;
        ListView.Columns[Col].Width := MaxWidth;
      end;
    finally
      CoUninitialize;
    end;
  except
    on E: Exception do
    begin
      ListItem := ListView.Items.Add;
      ListItem.Caption := 'Error: ' + E.Message;
      LogMemo.Lines.Add('Error: ' + E.Message);
    end;
  end;
end;

procedure QueryDriverPack(HardwareID: string);
var
  HttpClient: THTTPClient;
  Response: IHTTPResponse;
  JsonResponse: TJSONObject;
begin
  HttpClient := THTTPClient.Create;
  try
    // Send HTTP GET request to DriverPack API
    Response := HttpClient.Get('https://driverpack.io/en/catalog/' +
      HardwareID);

    if Response.StatusCode = 200 then
    begin
      JsonResponse := TJSONObject.ParseJSONValue(Response.ContentAsString)
        as TJSONObject;
      try
        if Assigned(JsonResponse) then
          ShowMessage('Driver information found: ' + JsonResponse.ToString)
        else
          ShowMessage('No valid JSON response received.');
      finally
        JsonResponse.Free;
      end;
    end
    else
      ShowMessage('Driver not found for Hardware ID: ' + HardwareID);
  finally
    HttpClient.Free;
  end;
end;

procedure GetHardwareIDs(StringGrid: TStringGrid);
var
  WbemLocator, WMIService, DeviceList, Device: OLEVariant;
  Enum: IEnumVariant;
  IValue: Cardinal;
  Row: Integer;
begin
  StringGrid.RowCount := 1; // Reset grid
  StringGrid.ColCount := 2; // Device Name and Hardware ID
  StringGrid.Cells[0, 0] := 'Device Name';
  StringGrid.Cells[1, 0] := 'Hardware ID';

  CoInitialize(nil);
  try
    WbemLocator := CreateOleObject('WbemScripting.SWbemLocator');
    WMIService := WbemLocator.ConnectServer('.', 'root\CIMV2');
    DeviceList := WMIService.ExecQuery
      ('SELECT Name, DeviceID FROM Win32_PnPEntity', 'WQL', 0);
    Enum := IUnknown(DeviceList._NewEnum) as IEnumVariant;

    Row := 1;
    while Enum.Next(1, Device, IValue) = 0 do
    begin
      StringGrid.RowCount := Row + 1;
      StringGrid.Cells[0, Row] := Device.Name;
      StringGrid.Cells[1, Row] := Device.DeviceID;
      Inc(Row);
      Device := Unassigned;
    end;
  finally
    CoUninitialize;
  end;
end;

procedure InstallDriverUpdates;
var
  UpdateSession: OLEVariant;
  UpdateSearcher: OLEVariant;
  UpdateInstaller: OLEVariant;
  SearchResult: OLEVariant;
  InstallationResult: OLEVariant;
begin
  CoInitialize(nil);
  try
    UpdateSession := CreateOleObject('Microsoft.Update.Session');
    UpdateSearcher := UpdateSession.CreateUpdateSearcher;
    SearchResult := UpdateSearcher.Search('Type="Driver"');

    if SearchResult.Updates.Count = 0 then
    begin
      ShowMessage('No updates to install.');
      Exit;
    end;

    UpdateInstaller := UpdateSession.CreateUpdateInstaller;
    UpdateInstaller.Updates := SearchResult.Updates;

    InstallationResult := UpdateInstaller.Install;
    if InstallationResult.ResultCode = 2 then
      ShowMessage('Updates installed successfully.')
    else
      ShowMessage('Some updates failed to install.');
  except
    on E: Exception do
      ShowMessage('Error installing updates: ' + E.Message);
  end;
  CoUninitialize;
end;

procedure DownloadUpdates;
var
  UpdateSession: OLEVariant;
  UpdateSearcher: OLEVariant;
  UpdateDownloader: OLEVariant;
  SearchResult: OLEVariant;
begin
  CoInitialize(nil);
  try
    UpdateSession := CreateOleObject('Microsoft.Update.Session');
    UpdateSearcher := UpdateSession.CreateUpdateSearcher;
    SearchResult := UpdateSearcher.Search('Type="Driver"');

    if SearchResult.Updates.Count = 0 then
    begin
      ShowMessage('No updates to download.');
      Exit;
    end;

    UpdateDownloader := UpdateSession.CreateUpdateDownloader;
    UpdateDownloader.Updates := SearchResult.Updates;
    UpdateDownloader.Download;

    ShowMessage('Updates downloaded successfully.');
  except
    on E: Exception do
      ShowMessage('Error downloading updates: ' + E.Message);
  end;
  CoUninitialize;
end;

procedure SearchForDriverUpdates;
var
  UpdateSearcher: OLEVariant;
  SearchResult: OLEVariant;
  Update: OLEVariant;
  i: Integer;
begin
  CoInitialize(nil);
  try
    UpdateSearcher := CreateOleObject('Microsoft.Update.Searcher');
    SearchResult := UpdateSearcher.Search('Type="Driver"');

    if SearchResult.Updates.Count = 0 then
    begin
      ShowMessage('No driver updates found.');
      Exit;
    end;

    for i := 0 to SearchResult.Updates.Count - 1 do
    begin
      Update := SearchResult.Updates.Item[i];
      ShowMessage(Format('Update %d: %s', [i + 1, Update.Title]));
    end;
  except
    on E: Exception do
      ShowMessage('Error searching for updates: ' + E.Message);
  end;
  CoUninitialize;
end;

procedure ListMissingDrivers(StringGrid1: TStringGrid);
var
  WbemLocator: OLEVariant;
  WMIService: OLEVariant;
  DeviceList: OLEVariant;
  Device: OLEVariant;
  Enum: IEnumVariant;
  IValue: Cardinal;
  Row: Integer;
begin
  StringGrid1.RowCount := 2;
  StringGrid1.ColCount := 2;
  StringGrid1.FixedRows := 1;
  StringGrid1.Cells[0, 0] := 'Device Name';
  StringGrid1.Cells[1, 0] := 'Driver Status';

  try
    CoInitialize(nil);
    try
      WbemLocator := CreateOleObject('WbemScripting.SWbemLocator');
      WMIService := WbemLocator.ConnectServer('.', 'root\CIMV2');

      DeviceList := WMIService.ExecQuery
        ('SELECT DeviceID, Name, ConfigManagerErrorCode FROM Win32_PnPEntity',
        'WQL', 0);

      Row := 1;
      Enum := IUnknown(DeviceList._NewEnum) as IEnumVariant;
      while Enum.Next(1, Device, IValue) = 0 do
      begin
        if VarIsNull(Device.ConfigManagerErrorCode) or
          (Device.ConfigManagerErrorCode <> 0) then
        begin
          StringGrid1.RowCount := Row + 1;
          StringGrid1.Cells[0, Row] := Device.Name;
          StringGrid1.Cells[1, Row] := 'Missing or Problematic';
          Inc(Row);
        end;
        Device := Unassigned;
      end;

      if Row = 1 then
      begin
        StringGrid1.Cells[0, 1] := 'No missing drivers';
        StringGrid1.Cells[1, 1] := '';
      end;
    finally
      CoUninitialize;
    end;
  except
    on E: Exception do
    begin
      StringGrid1.RowCount := 2;
      StringGrid1.Cells[0, 1] := 'Error';
      StringGrid1.Cells[1, 1] := E.Message;
    end;
  end;
end;

procedure AdjustColumnWidths(StringGrid: TStringGrid);
var
  Col, Row: Integer;
  MaxWidth, CellWidth: Integer;
begin
  for Col := 0 to StringGrid.ColCount - 1 do
  begin
    MaxWidth := 0;
    for Row := 0 to StringGrid.RowCount - 1 do
    begin
      CellWidth := StringGrid.Canvas.TextWidth(StringGrid.Cells[Col, Row]) + 10;
      if CellWidth > MaxWidth then
        MaxWidth := CellWidth;
    end;
    StringGrid.ColWidths[Col] := MaxWidth;
  end;
end;

// -----------------------------------------------------------------------------
// Event handlers
// -----------------------------------------------------------------------------
procedure TForm3.btnRefreshClick(Sender: TObject);
begin
   // Cerrar
  ServiceInfo1.Active := False;
  // Abrir
  ServiceInfo1.Active := True;

  // Refrescar
  CargarDatosGrid();
end;

procedure TForm3.Button10Click(Sender: TObject);
begin
DisableSysMain(LogMemo);

end;

procedure TForm3.Button11Click(Sender: TObject);
begin
DisableUnnecessaryScheduledTasks(LogMemo);

end;

procedure TForm3.Button12Click(Sender: TObject);
begin
 DisableBackgroundApps(LogMemo);

end;

procedure TForm3.Button13Click(Sender: TObject);
begin
EnableFastStartup(LogMemo);

end;

procedure TForm3.Button14Click(Sender: TObject);
begin
 AdjustForBestPerformance(LogMemo);

end;

procedure TForm3.Button15Click(Sender: TObject);
begin
RepairSystemFiles(LogMemo);
end;

procedure TForm3.Button16Click(Sender: TObject);
begin
 DisableWindowsDefender(LogMemo);

end;

procedure TForm3.Button17Click(Sender: TObject);
begin
EnableWindowsDefender(LogMemo)
end;

procedure TForm3.Button18Click(Sender: TObject);
begin
DisableWindowsUpdate(logMemo);
end;

procedure TForm3.Button19Click(Sender: TObject);
begin
EnableWindowsUpdate(LogMemo);
end;

procedure TForm3.Button1Click(Sender: TObject);
begin
 SearchMotherboardDrivers

end;






procedure TForm3.SearchMotherboardDrivers;
var
  WbemLocator, WMIService, MBList, MB: OLEVariant;
  Enum: IEnumVariant;
  Dummy: Cardinal;
  MBManufacturer, MBProduct, Query, SearchURL: string;
begin
  LogMemo.Lines.Add('Querying motherboard information for online search...');
  CoInitialize(nil);
  try
    try
      // Create the WMI locator and connect to the CIMV2 namespace
      WbemLocator := CreateOleObject('WbemScripting.SWbemLocator');
      WMIService := WbemLocator.ConnectServer('.', 'root\CIMV2');
      // Query Win32_BaseBoard for Manufacturer and Product
      MBList := WMIService.ExecQuery('SELECT Manufacturer, Product FROM Win32_BaseBoard');
      Enum := IUnknown(MBList._NewEnum) as IEnumVariant;
      if Enum.Next(1, MB, Dummy) = 0 then
      begin
        MBManufacturer := VarToStr(MB.Manufacturer);
        MBProduct := VarToStr(MB.Product);
      end
      else
      begin
        LogMemo.Lines.Add('No motherboard information found.');
        Exit;
      end;
    except
      on E: Exception do
      begin
        LogMemo.Lines.Add('Error retrieving motherboard info: ' + E.Message);
        Exit;
      end;
    end;
  finally
    CoUninitialize;
  end;

  // Construct a search query string using the retrieved info.
  // You can modify the query to target specific manufacturers' websites if desired.
  Query := Format('%s %s motherboard driver download', [MBManufacturer, MBProduct]);
  // URL encode the query so that it is safe for a URL
  Query := TNetEncoding.URL.Encode(Query);
  SearchURL := 'https://www.google.com/search?q=' + Query;

  LogMemo.Lines.Add('Searching online for motherboard drivers with URL: ' + SearchURL);
  // Open the URL in the default browser
  ShellExecute(0, 'open', PChar(SearchURL), nil, nil, SW_SHOWNORMAL);
end;


procedure TForm3.ServicesShow(Sender: TObject);
begin
ServiceInfo1.Active := True;

  CargarDatosGrid();

end;

procedure TForm3.Button20Click(Sender: TObject);
begin
 CreateGodModeFolder
end;

procedure TForm3.Button21Click(Sender: TObject);
begin
SetDarkMode(True, LogMemo);
end;

procedure TForm3.Button22Click(Sender: TObject);
begin
SetDarkMode(False, LogMemo);

end;

procedure TForm3.Button23Click(Sender: TObject);
begin
EnableStorageSense(LogMemo);
end;

procedure TForm3.Button24Click(Sender: TObject);
begin
 DisableStorageSense(LogMemo);
end;



procedure OpenStartupAppsSettings;
begin
  if TOSVersion.Check(10) then
    // For Windows 10 and later, open the built‑in Startup Apps settings.
    ShellExecute(0, 'open', 'ms-settings:startupapps', nil, nil, SW_SHOWNORMAL)
  else
    // For Vista, Windows 7, and Windows 8, open the Startup folder for the current user.
    ShellExecute(0, 'open', 'shell:startup', nil, nil, SW_SHOWNORMAL);
end;

procedure TForm3.Button25Click(Sender: TObject);
begin
 OpenStartupAppsSettings
end;

procedure TForm3.Button26Click(Sender: TObject);
begin
 SetConsumerFeatures(true,LogMemo);
end;

procedure TForm3.Button27Click(Sender: TObject);
begin
 SetConsumerFeatures(False, LogMemo);
end;

procedure TForm3.Button28Click(Sender: TObject);
begin
 DebloatEdgeNoJSON(LogMemo);

end;

procedure TForm3.Button29Click(Sender: TObject);
begin
SetShowHiddenFiles(True, True, LogMemo);

end;

procedure TForm3.Button2Click(Sender: TObject);
var
  i:integer;
  Str:string;
begin
  Str := sgServices.Cells[1, sgServices.Row];
  i := ServiceInfo1.StartService('DisplayName', Str);
  sbMain.SimpleText := 'Resultado: ' + ServiceInfo1.GetErrorControlAsString(i);

  // refrescar
  btnRefreshClick(nil);
end;

function PostExample: string;
var
  lHTTP: TIdHTTP;
  lParamList: TStringList;
begin
  lParamList := TStringList.Create;
  lParamList.Add('id=1');

  lHTTP := TIdHTTP.Create;
  try
    Result := lHTTP.Post
      ('http://driverpack.io/en/search?query=UHD+Graphics+630', lParamList);
  finally
    lHTTP.Free;
    lParamList.Free;
  end;
end;


procedure TForm3.HighlightSearchMatches(const AFilter: string);
var
  i, j: Integer;
  LItem: TListItem;
  IsMatch: Boolean;
begin
  ListView1.Items.BeginUpdate;
  try
    // Loop over each item in the ListView.
    for i := 0 to ListView1.Items.Count - 1 do
    begin
      LItem := ListView1.Items[i];
      IsMatch := False;

      // If the filter is empty, you might want to clear the selection.
      if Trim(AFilter) = '' then
        IsMatch := False
      else
      begin
        // Check the main caption.
        if Pos(LowerCase(AFilter), LowerCase(LItem.Caption)) > 0 then
          IsMatch := True
        else
          // Check each subitem.
          for j := 0 to LItem.SubItems.Count - 1 do
            if Pos(LowerCase(AFilter), LowerCase(LItem.SubItems[j])) > 0 then
            begin
              IsMatch := True;
              Break;
            end;
      end;

      // Highlight the row if a match is found.
      LItem.Selected := IsMatch;
    end;
  finally
    ListView1.Items.EndUpdate;
  end;
end;



procedure TForm3.Button30Click(Sender: TObject);
begin
 SetShowHiddenFiles(False, False, LogMemo);

end;

procedure TForm3.Button31Click(Sender: TObject);
begin
 try
    OpenBackgroundAppsSettings;
  except
    on E: Exception do
      ShowMessage(E.Message);
  end;
end;

procedure TForm3.Button32Click(Sender: TObject);
begin
 ResetWindowsUpdate(LogMemo);

end;

procedure TForm3.Button33Click(Sender: TObject);
begin
 InvokeUltimatePerformance('Enable', LogMemo);

end;

procedure TForm3.Button34Click(Sender: TObject);
begin
 InvokeUltimatePerformance('Disable', LogMemo);

end;

procedure TForm3.Button35Click(Sender: TObject);
begin
 CreateSystemRestorePoint('Before installing new software', LogMemo);

end;

procedure TForm3.Button36Click(Sender: TObject);
begin
  ToggleSystemRestore(True, LogMemo);

end;

procedure TForm3.Button37Click(Sender: TObject);
begin
ToggleSystemRestore(False, LogMemo);

end;

 procedure OpenDefenderSettings;
begin
  if TOSVersion.Check(10) then
    // On Windows 10/11, open Windows Security (Defender) settings
    ShellExecute(0, 'open', 'ms-settings:windowsdefender', nil, nil, SW_SHOWNORMAL)
  else
    // On Windows 7, for example, open the Windows Defender Control Panel item
    ShellExecute(0, 'open', 'control.exe', '/name Microsoft.WindowsDefender', nil, SW_SHOWNORMAL);
end;
procedure TForm3.Button38Click(Sender: TObject);
begin
OpenDefenderSettings
end;
procedure RunChrisTitusScript(LogMemo: TMemo);
var
  sei: TShellExecuteInfo;
  ExitCode: DWORD;
  StartTime: TDateTime;
  ElapsedMS: Integer;
  SimulatedProgress: Integer;
begin
  // Initialize ProgressBar2 on Form3
  Form3.ProgressBar2.Min := 0;
  Form3.ProgressBar2.Max := 100;
  Form3.ProgressBar2.Position := 0;
  Application.ProcessMessages;

  LogMemo.Lines.Add('Starting Chris Titus script execution...');

  FillChar(sei, SizeOf(sei), 0);
  sei.cbSize := SizeOf(sei);
  sei.fMask := SEE_MASK_NOCLOSEPROCESS or SEE_MASK_FLAG_NO_UI;
  sei.lpVerb := 'runas'; // run as administrator
  sei.lpFile := 'PowerShell.exe';
  // Using -NoProfile and running our command
  sei.lpParameters := PChar('-NoProfile -Command "iwr -useb https://christitus.com/win | iex"');
  sei.nShow := SW_HIDE; // hide the PowerShell window

  if ShellExecuteEx(@sei) then
  begin
    // Start a timer to simulate progress
    StartTime := Now;
    repeat
      // Wait for a short interval (250 ms) so we can update progress
      if WaitForSingleObject(sei.hProcess, 250) = WAIT_TIMEOUT then
      begin
        // Simulate progress based on elapsed time.
        // For example, calculate elapsed milliseconds and map to a value up to 90.
        ElapsedMS := Trunc((Now - StartTime) * 24 * 60 * 60 * 1000);
        SimulatedProgress := ElapsedMS div 50; // adjust divisor to slow or speed progress
        if SimulatedProgress > 90 then
          SimulatedProgress := 90;
        Form3.ProgressBar2.Position := SimulatedProgress;
        Application.ProcessMessages;
      end;
    until (WaitForSingleObject(sei.hProcess, 0) <> WAIT_TIMEOUT);

    // When the process finishes, get its exit code
    if GetExitCodeProcess(sei.hProcess, ExitCode) then
      LogMemo.Lines.Add(Format('Chris Titus script finished with exit code %d.', [ExitCode]))
    else
      LogMemo.Lines.Add('Chris Titus script finished, exit code not retrieved.');

    CloseHandle(sei.hProcess);
  end
  else
    LogMemo.Lines.Add(Format('Failed to run Chris Titus script. Error code: %d', [GetLastError]));

  // Finalize progress bar update to 100%
  Form3.ProgressBar2.Position := 100;
  Application.ProcessMessages;
end;

procedure TForm3.Button39Click(Sender: TObject);
begin
 RunChrisTitusScript(LogMemo);
end;

procedure TForm3.Button3Click(Sender: TObject);
var
  i:integer;
  Str:string;
begin
  Str := sgServices.Cells[1, sgServices.Row];
  i := ServiceInfo1.PauseService('DisplayName', Str);
  sbMain.SimpleText := 'Resultado: ' + ServiceInfo1.GetErrorControlAsString(i);
  // refrescar
  btnRefreshClick(nil);

end;

procedure TForm3.Button41Click(Sender: TObject);
begin
  UpdateCheckboxesFromStatus(form3.lvStartUp);
end;

procedure TForm3.Button42Click(Sender: TObject);
begin
 DisableNotificationCenter(LogMemo);
end;

procedure TForm3.Button43Click(Sender: TObject);
begin
EnableNotificationCenter(LogMemo);
end;

procedure TForm3.Button44Click(Sender: TObject);
begin
  SetRecentItemsHistory(False, LogMemo);

end;

procedure TForm3.Button45Click(Sender: TObject);
begin
SetRecentItemsHistory(True, LogMemo);

end;

procedure TForm3.Button46Click(Sender: TObject);
const
  URL = 'https://downloads.malwarebytes.com/file/mb-windows?_gl=1*12qzyx6*_gcl_au*MTM5NTA2Mzc3My4xNzQyOTk1Nzk3*_ga*MTU5Mjc1MTI2OS4xNzQyOTk1Nzk4*_ga_K8KCHE3KSC*MTc0Mjk5NTc5Ny4xLjEuMTc0Mjk5NTgxMi40NS4wLjA.';
var
  DocumentsPath, LocalExe: string;
begin
  try
    // Get the user's Documents folder
    DocumentsPath := TPath.GetDocumentsPath;

    // Set the local executable path
    LocalExe := TPath.Combine(DocumentsPath, 'MalwareBytes.exe');

    // Download and install
    DownloadAndInstall(URL, LocalExe);

    ShowMessage('Download and installation started successfully.');
  except
    on E: Exception do
      ShowMessage('Error: ' + E.Message);
  end;
end;

procedure TForm3.Button47Click(Sender: TObject);
  const
  URL = 'https://www.avast.com/en-us/download-thank-you.php?product=FAV-ONLINE-FAD&locale=en-us&direct=1';
var
  DocumentsPath, LocalExe: string;
begin
  try
    // Get the user's Documents folder
    DocumentsPath := TPath.GetDocumentsPath;

    // Set the local executable path
    LocalExe := TPath.Combine(DocumentsPath, 'avast_free_antivirus_setup_online.exe');

    // Download and install
    DownloadAndInstall(URL, LocalExe);

    ShowMessage('Download and installation started successfully.');
  except
    on E: Exception do
      ShowMessage('Error: ' + E.Message);
  end;
end;

procedure TForm3.Button48Click(Sender: TObject);
 const
  URL = 'https://bits.avcdn.net/productfamily_ANTIVIRUS/insttype_FREE/platform_WIN_AVG/installertype_ONLINE/build_RELEASE/cookie_mmm_bav_998_999_000_m:dlid_FREEGSR-HP?alt=en-us';
var
  DocumentsPath, LocalExe: string;
begin
  try
    // Get the user's Documents folder
    DocumentsPath := TPath.GetDocumentsPath;

    // Set the local executable path
    LocalExe := TPath.Combine(DocumentsPath, 'avg_antivirus_free_setup.exe');

    // Download and install
    DownloadAndInstall(URL, LocalExe);

    ShowMessage('Download and installation started successfully.');
  except
    on E: Exception do
      ShowMessage('Error: ' + E.Message);
  end;
end;

procedure TForm3.Button49Click(Sender: TObject);
begin
  try
    // Opens the free version download page for SUPERAntiSpyware.
    OpenURL('https://www.superantispyware.com/download-free/');
  except
    on E: Exception do
      ShowMessage('Error opening SUPERAntiSpyware download page: ' + E.Message);
  end;
end;

procedure TForm3.Button4Click(Sender: TObject);
begin
 //CheckForDriverUpdates
 CheckForDriverUpdates_WMI(listview2,logmemo);
  Form3.ListView1.Visible := False;
  Form3.ListView2.Visible := True;
  form3.ListView2.Align:= AlClient;
end;

procedure TForm3.Button50Click(Sender: TObject);
begin
  try
    // Opens the download page for AdwCleaner (by Malwarebytes).
    OpenURL('https://www.malwarebytes.com/adwcleaner/');
  except
    on E: Exception do
      ShowMessage('Error opening AdwCleaner download page: ' + E.Message);
  end;
end;

procedure TForm3.Button51Click(Sender: TObject);
begin
    try
    // Opens the HitmanPro download page (free trial version available).
    OpenURL('https://www.hitmanpro.com/en-us/downloads');
  except
    on E: Exception do
      ShowMessage('Error opening HitmanPro download page: ' + E.Message);
  end;
end;

procedure TForm3.Button52Click(Sender: TObject);
begin
   try
    // Opens the download page for the Emsisoft Emergency Kit.
    OpenURL('https://www.emsisoft.com/en/home/emergencykit/');
  except
    on E: Exception do
      ShowMessage('Error opening Emsisoft Emergency Kit download page: ' + E.Message);
  end;
end;

procedure TForm3.Button53Click(Sender: TObject);
begin
   try
    // Opens the HitmanPro download page (free trial version available).
    OpenURL('https://www.drivereasy.com/');
  except
    on E: Exception do
      ShowMessage('Error opening HitmanPro download page: ' + E.Message);
  end;
end;

procedure TForm3.Button54Click(Sender: TObject);
const
  URL = 'https://download.ccleaner.com/portable/ccsetup634.zip';
var
  DocumentsPath, LocalZip, ExtractFolder, Executable: string;
begin
  try
    // Get the user's Documents folder path
    DocumentsPath := TPath.GetDocumentsPath;

    // Define paths using the Documents folder
    LocalZip := TPath.Combine(DocumentsPath, 'ccsetup634.zip');
    ExtractFolder := TPath.Combine(DocumentsPath, 'CCleanerPortable');
    Executable := TPath.Combine(ExtractFolder, 'ccleaner.exe');

    // Step 1: Download with progress
    DownloadFileWithProgress(URL, LocalZip, Progressbar1, LabelProgress);

    // Step 2: Extract the ZIP file
    ExtractZip(LocalZip, ExtractFolder);

    // Step 3: Run the executable after extraction
    if ShellExecute(Application.Handle, 'open', PChar(Executable),
      nil, nil, SW_SHOWNORMAL) <= 32 then
      raise Exception.Create('Failed to start the executable.');

    ShowMessage('Download, extraction, and execution completed successfully.');
  except
    on E: Exception do
      ShowMessage('Error: ' + E.Message);
  end;
end;




procedure TForm3.Button5Click(Sender: TObject);
begin
 InstallDriverUpdates
end;

procedure TForm3.Button61Click(Sender: TObject);
var
  SInfo:TComputerSystemInfo;
  p:TComputerSystemProperties;
  Str:String;
begin

    SInfo := TComputerSystemInfo.Create(nil);
  sInfo.Active := True;
  p := sInfo.ComputerSystemProperties;


  lbComputerName.Caption:= 'Computer Name: ' +p.Caption;
  lbDescription.Caption:= 'Description: ' + p.Description;

  Str := Str +
    'Computer Name: ' + p.Caption + sLineBreak +
    'Descripcion: ' + p.Description + sLineBreak +
    'User Name: ' + p.UserName + sLineBreak +
    'Domain: ' + p.Domain + sLineBreak +
    'Roles: ' + p.RolesAsString + sLineBreak +
    'Manufacturer: ' + p.Manufacturer + sLineBreak +
    'Model: ' + p.Model + sLineBreak +
    'System Family: ' + p.SystemFamily + sLineBreak +
    'System Type: ' + p.SystemType + sLineBreak;
  ShowMessage(Str);
end;

procedure TForm3.Button62Click(Sender: TObject);
begin
  //SplashForm.hide;
end;

procedure TForm3.Button6Click(Sender: TObject);
var
  i:integer;
  Str, ini:string;
begin
  Str := sgServices.Cells[1, sgServices.Row];
  ini := cbStart.Items[cbStart.ItemIndex];
  i := ServiceInfo1.ChangeStartMode('DisplayName', Str, ini);
  sbMain.SimpleText := 'Resultado: ' + ServiceInfo1.GetErrorControlAsString(i);
  // refrescar
  btnRefreshClick(nil);


end;

procedure TForm3.Button7Click(Sender: TObject);
var
  Whitelist: TStringList;
begin
  Whitelist := TStringList.Create;
  try
    LoadServiceWhitelist(Whitelist);
    SetNonEssentialServicesToManual(Whitelist, LogMemo);
  finally
    Whitelist.Free;
  end;
end;


procedure TForm3.Button8Click(Sender: TObject);
begin
  DisableWindowsSearchIndexing(LogMemo);

end;

procedure TForm3.Button9Click(Sender: TObject);
begin
 CleanUpTemporaryFilesAndCaches(LogMemo);

end;

procedure TForm3.chkHideUnknownClick(Sender: TObject);
begin
  ListAllDrivers(ListView1, LogMemo);
end;

procedure TForm3.chkNoDriverClick(Sender: TObject);
begin
ListAllDrivers(ListView1, LogMemo);
end;

// >>> ADDED 5: This is the actual "search/filter" procedure. It rebuilds ListView1 from FOriginalItems <<<
procedure TForm3.ApplySearchFilter(const AFilter: string);
var
  i, j: Integer;
  RowData: string;
  Fields: TArray<string>;
  LItem: TListItem;
  IsMatch: Boolean;
begin
  LogMemo.Lines.Add('=== ApplySearchFilter called with AFilter = "' + AFilter + '" ===');

  ListView1.Items.BeginUpdate;
  try
    // Clear current items and selection
    ListView1.Clear;
    ListView1.ClearSelection;

    if (FOriginalItems = nil) or (FOriginalItems.Count = 0) then
    begin
      LogMemo.Lines.Add('No data in FOriginalItems. Did you call ListAllDrivers first?');
      Exit;
    end;

    LogMemo.Lines.Add('FOriginalItems.Count=' + FOriginalItems.Count.ToString);

    for i := 0 to FOriginalItems.Count - 1 do
    begin
      RowData := FOriginalItems[i];
      LogMemo.Lines.Add(Format('Row #%d raw data: "%s"', [i, RowData]));

      Fields := RowData.Split(['|']);

      // If there are no fields, skip the row
      if Length(Fields) = 0 then
      begin
        LogMemo.Lines.Add('  Skipping: no fields found.');
        Continue;
      end;

      // Assume a match if filter is empty
      IsMatch := (Trim(AFilter) = '');
      // Otherwise, check every field in the row
      if not IsMatch then
      begin
        for j := 0 to High(Fields) do
        begin
          if Pos(LowerCase(AFilter), LowerCase(Fields[j])) > 0 then
          begin
            IsMatch := True;
            Break;
          end;
        end;
      end;

      if IsMatch then
      begin
        LogMemo.Lines.Add('  MATCH => adding to ListView.');
        LItem := ListView1.Items.Add;
        // First field becomes the caption; the rest become subitems.
        LItem.Caption := Fields[0];
        for j := 1 to High(Fields) do
          LItem.SubItems.Add(Fields[j]);
        LItem.Selected := True;
      end
      else
        LogMemo.Lines.Add('  NO match => skipping this row.');
    end;

    LogMemo.Lines.Add('ApplySearchFilter done. Items in the new, filtered ListView: ' +
      ListView1.Items.Count.ToString);
  finally
    ListView1.Items.EndUpdate;
  end;
end;

// >>> ADDED 6: When the user types, we restart the timer to avoid searching on each keystroke <<<
procedure TForm3.EditFilterChange(Sender: TObject);
begin
  try
    // If you want to debounce, you could use a timer;
    // otherwise, simply call the highlight procedure:
    HighlightSearchMatches(EditFilter.Text);
  except
    on E: Exception do
      LogMemo.Lines.Add('Error in EditFilterChange: ' + E.Message);
  end;
end;


procedure TForm3.EditFilterMouseLeave(Sender: TObject);
begin
 ListAllDrivers(ListView1, LogMemo);
end;

procedure TForm3.FilterTimerTimer(Sender: TObject);
begin
   FilterTimer.Enabled := False;
  if Trim(EditFilter.Text) = '' then
    ListAllDrivers(ListView1, LogMemo)
  else
    ApplySearchFilter(EditFilter.Text);
end;



procedure TForm3.FindDriver1Click(Sender: TObject);
var
  SelectedItem: TListItem;
  DriverKey: string;
begin
  if not Assigned(ListView1.Selected) then
  begin
    ShowMessage('No row selected!');
    Exit;
  end;

  SelectedItem := ListView1.Selected;

  // Assuming the driver key (from SPDRP_DRIVER) is stored in the 5th subitem
  DriverKey := SelectedItem.SubItems[4]; // Adjust index based on your ListView column order
  if DriverKey.IsEmpty then
  begin
    ShowMessage('Driver key is not available for the selected item.');
    Exit;
  end;

  LocateDriverOnOS(DriverKey);
end;

procedure TForm3.FormClose(Sender: TObject; var Action: TCloseAction);
begin
  ApplyStartupCheckboxes(lvStartUp, LogMemo);
  SaveStartupState(lvStartUp, 'StartupApps.ini');
  //ShowMessage('Startup settings have been updated and saved.');
  Application.Terminate;
end;

procedure TForm3.FormCreate(Sender: TObject);
begin

SplashForm.show;
   // Show the splash form
// Application.CreateForm(TSplashForm, SplashForm);
//  SplashForm.Show;


   if not IsElevated then
  begin
    // Relaunch the application with administrative rights.
    if ShellExecute(0, 'runas', PChar(ParamStr(0)), nil, nil, SW_SHOWNORMAL) > 32 then
      Application.Terminate
    else
      raise Exception.Create('Unable to restart as administrator.');
  end;

  ShowMainInfo;

  FUpdateList := TList<OleVariant>.Create;
  // Optionally, ensure your ListView2 is set up:
//  ListView2.ViewStyle := vsReport;
//  ListView2.Checkboxes := True;
  //ListView2.Columns.Clear;
//  with ListView2.Columns.Add do
//    Caption := 'Title';
//  with ListView2.Columns.Add do
//    Caption := 'Description';
  ListView1.DoubleBuffered := True;
//  SplashForm.close;
//  Form3.show;
end;

procedure TForm3.FormDestroy(Sender: TObject);
begin
 FUpdateList.Free;
 FreeAndNil(SplashForm);
 Application.Terminate;
end;

procedure TForm3.FormPaint(Sender: TObject);
begin
//SplashForm.hide;
end;

procedure TForm3.FormShow(Sender: TObject);
begin
ListAllDrivers(Listview1,logmemo);
 ListAllStartupApps(lvStartUp, LogMemo);
  LoadStartupState(lvStartUp, 'StartupApps.ini');

 SplashForm.Hide;
end;

procedure TForm3.IndyDrivePackClick(Sender: TObject);
begin
  IndyCheckDriverPack
end;

// For example, if the user double-clicks a row in your main ListView:
procedure TForm3.ListView1DblClick(Sender: TObject);
var
  LItem: TListItem;
  VendorID, DeviceID, URL: string;
begin
  if not Assigned(ListView1.Selected) then
  begin
    ShowMessage('No row selected!');
    Exit;
  end;

  LItem := ListView1.Selected;
  // Retrieve VendorID and DeviceID from the selected row's subitems
  VendorID := LItem.SubItems[0]; // Example: "8086"
  DeviceID := LItem.SubItems[1]; // Example: "3E92"

  // Log the retrieved IDs to the memo
  Form3.LogMemo.Lines.Add('VendorID: ' + VendorID);
  Form3.LogMemo.Lines.Add('DeviceID: ' + DeviceID);

  // Construct the URL
  URL := Format('https://driverpack.io/en/hwids/PCI%%5CVEN_%s%%26DEV_%s',
    [VendorID, DeviceID]);
  LogMemo.Lines.Add(URL);
  // Open the URL in the default web browser
  try
    ShellExecute(0, 'open', PChar(URL), nil, nil, SW_SHOWNORMAL);
  except
    on E: Exception do
      ShowMessage('Error opening browser: ' + E.Message);
  end;
end;

procedure TForm3.PopupMenu1Popup(Sender: TObject);
begin
  // Enable the menu item only if a row is selected
  PopupMenu1.Items[0].Enabled := Assigned(ListView1.Selected);
end;

// >>> ADDED 8: Create and free FOriginalItems at runtime. One simple approach is to set these in Form events. <<<
initialization

// Create our backup list for searching
FOriginalItems := TStringList.Create;

finalization

// Free it on app close
FreeAndNil(FOriginalItems);

end.
